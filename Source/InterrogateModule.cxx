/*
 * This file generated by:
 * F:/P3D/1.9.0-1/built_x64/bin/interrogate -D__inline -DWIN32 -DWIN32_VC -D__int64=long -DCPPPARSER -DP3_INTERROGATE=1 -D__cplusplus -fnames -string -refcount -assert -Dvolatile= -SF:/P3D/1.9.0-1/built_x64/include/parser-inc -SF:/P3D/1.9.0-1/built_x64/include/ -oc Source/InterrogateModule.cxx -od Source/InterrogateModule.in -python-native -module LUI -library LUI -srcdir E:/Projects/Brainz stuff/LUI/Source config_lui.h luiAtlas.h luiAtlasDescriptor.h luiAtlasPacker.h luiAtlasPool.h luiBaseElement.h luiNode.h luiRoot.h luiSprite.h luiSprite_ext.h luiVertexPool.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_LUI
#include "py_panda.h"
#include "extension.h"

#include "config_lui.h"
#include "dconfig.h"
#include "filename.h"
#include <fstream>
#include "internalName.h"
#include "luiAtlas.h"
#include "luiAtlasDescriptor.h"
#include "luiAtlasPacker.h"
#include "luiAtlasPool.h"
#include "luiBaseElement.h"
#include "luiNode.h"
#include "luiRoot.h"
#include "luiSprite.h"
#include "luiSprite_ext.h"
#include "luiVertexPool.h"
#include "luse.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pandasymbols.h"
#include "referenceCount.h"
#include "texture.h"
#include "texturePool.h"
#include "virtualFileSystem.h"

#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif

//********************************************************************
//*** prototypes for .. Global
//********************************************************************
//********************************************************************
//*** prototypes for .. LUIAtlas
//********************************************************************
typedef LUIAtlas LUIAtlas_localtype;
Define_Module_ClassRef(LUI, LUIAtlas, LUIAtlas_localtype, LUIAtlas);

//********************************************************************
//*** prototypes for .. LUIAtlasDescriptor
//********************************************************************
typedef LUIAtlasDescriptor LUIAtlasDescriptor_localtype;
Define_Module_ClassRef(LUI, LUIAtlasDescriptor, LUIAtlasDescriptor_localtype, LUIAtlasDescriptor);

//********************************************************************
//*** prototypes for .. LUIAtlasPacker
//********************************************************************
typedef LUIAtlasPacker LUIAtlasPacker_localtype;
Define_Module_ClassRef(LUI, LUIAtlasPacker, LUIAtlasPacker_localtype, LUIAtlasPacker);

//********************************************************************
//*** prototypes for .. LUIAtlasPool
//********************************************************************
typedef LUIAtlasPool LUIAtlasPool_localtype;
Define_Module_Class_Private(LUI, LUIAtlasPool, LUIAtlasPool_localtype, LUIAtlasPool);

//********************************************************************
//*** prototypes for .. LUIBaseElement
//********************************************************************
typedef LUIBaseElement LUIBaseElement_localtype;
Define_Module_Class(LUI, LUIBaseElement, LUIBaseElement_localtype, LUIBaseElement);

//********************************************************************
//*** prototypes for .. LUINode
//********************************************************************
typedef LUINode LUINode_localtype;
Define_Module_ClassRef(LUI, LUINode, LUINode_localtype, LUINode);

//********************************************************************
//*** prototypes for .. LUISprite
//********************************************************************
typedef LUISprite LUISprite_localtype;
Define_Module_ClassRef(LUI, LUISprite, LUISprite_localtype, LUISprite);

//********************************************************************
//*** prototypes for .. LUIRoot
//********************************************************************
typedef LUIRoot LUIRoot_localtype;
Define_Module_Class(LUI, LUIRoot, LUIRoot_localtype, LUIRoot);

//********************************************************************
//*** prototypes for .. External Objects
//********************************************************************
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LVector2f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_Texture;

//********************************************************************
//*** Functions for .. Global
//********************************************************************
//********************************************************************
//*** Functions for .. LUIAtlas
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool LUIAtlas::load_descriptor_file(basic_string< char > const &descriptor_path)
 *******************************************************************/
static PyObject *Dtool_LUIAtlas_load_descriptor_file_4(PyObject *self, PyObject *arg) {
  LUIAtlas *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIAtlas, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-bool LUIAtlas::load_descriptor_file(basic_string< char > const &descriptor_path)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      bool return_value = (local_this)->load_descriptor_file(basic_string<char>(param1_str, param1_len));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyBool_FromLong(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIAtlas.load_descriptor_file() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "load_descriptor_file(LUIAtlas this, str descriptor_path)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlas_load_descriptor_file_4_comment =
  "C++ Interface:\n"
  "load_descriptor_file(LUIAtlas this, str descriptor_path)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIAtlas_load_descriptor_file_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool LUIAtlas::load_texture(basic_string< char > const &texture_path)
 *******************************************************************/
static PyObject *Dtool_LUIAtlas_load_texture_5(PyObject *self, PyObject *arg) {
  LUIAtlas *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIAtlas, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-bool LUIAtlas::load_texture(basic_string< char > const &texture_path)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      bool return_value = (local_this)->load_texture(basic_string<char>(param1_str, param1_len));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyBool_FromLong(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIAtlas.load_texture() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "load_texture(LUIAtlas this, str texture_path)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlas_load_texture_5_comment =
  "C++ Interface:\n"
  "load_texture(LUIAtlas this, str texture_path)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIAtlas_load_texture_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Texture *LUIAtlas::get_texture(void)
 *******************************************************************/
static PyObject *Dtool_LUIAtlas_get_texture_6(PyObject *self) {
  LUIAtlas *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIAtlas, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline Texture *LUIAtlas::get_texture(void)
    Texture *return_value = (local_this)->get_texture();
    if (return_value != (Texture *)0) {
      return_value->ref();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_Texture, true, false, (return_value)->as_typed_object()->get_type_index());
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIAtlas.get_texture() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_texture(LUIAtlas this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlas_get_texture_6_comment =
  "C++ Interface:\n"
  "get_texture(LUIAtlas this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIAtlas_get_texture_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool LUIAtlas::has_entry(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_LUIAtlas_has_entry_7(PyObject *self, PyObject *arg) {
  LUIAtlas *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIAtlas, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline bool LUIAtlas::has_entry(basic_string< char > const &name)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      bool return_value = (local_this)->has_entry(basic_string<char>(param1_str, param1_len));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyBool_FromLong(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIAtlas.has_entry() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "has_entry(LUIAtlas this, str name)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlas_has_entry_7_comment =
  "C++ Interface:\n"
  "has_entry(LUIAtlas this, str name)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIAtlas_has_entry_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int LUIAtlas::get_size(void)
 *******************************************************************/
static PyObject *Dtool_LUIAtlas_get_size_9(PyObject *self) {
  LUIAtlas *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIAtlas, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline int LUIAtlas::get_size(void)
    int return_value = (local_this)->get_size();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
#if PY_MAJOR_VERSION >= 3
    return PyLong_FromLong(return_value);
#else
    return PyInt_FromLong(return_value);
#endif
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIAtlas.get_size() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_size(LUIAtlas this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlas_get_size_9_comment =
  "C++ Interface:\n"
  "get_size(LUIAtlas this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIAtlas_get_size_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LUIAtlas::LUIAtlas(void)
 *******************************************************************/
int Dtool_Init_LUIAtlas(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-LUIAtlas::LUIAtlas(void)
  LUIAtlas *return_value = new LUIAtlas();
  return_value->ref();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    delete return_value;
    return -1;
  }
#endif
  return DTool_PyInit_Finalize(self, return_value, &Dtool_LUIAtlas, true, false);

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "LUIAtlas()\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_LUIAtlas(PyObject *self, PyObject *args) {
  return Dtool_Init_LUIAtlas(self, args, NULL);
}

inline void *Dtool_UpcastInterface_LUIAtlas(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUIAtlas) {
    printf("LUIAtlas ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUIAtlas *local_this = (LUIAtlas *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUIAtlas) {
    return local_this;
  }
  if (requested_type == &Dtool_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUIAtlas(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUIAtlas) {
    return from_this;
  }
  if (from_type == &Dtool_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIAtlas*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. LUIAtlasDescriptor
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LUIAtlasDescriptor::LUIAtlasDescriptor(void)
 *******************************************************************/
int Dtool_Init_LUIAtlasDescriptor(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-LUIAtlasDescriptor::LUIAtlasDescriptor(void)
  LUIAtlasDescriptor *return_value = new LUIAtlasDescriptor();
  return_value->ref();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    delete return_value;
    return -1;
  }
#endif
  return DTool_PyInit_Finalize(self, return_value, &Dtool_LUIAtlasDescriptor, true, false);

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "LUIAtlasDescriptor()\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_LUIAtlasDescriptor(PyObject *self, PyObject *args) {
  return Dtool_Init_LUIAtlasDescriptor(self, args, NULL);
}

inline void *Dtool_UpcastInterface_LUIAtlasDescriptor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUIAtlasDescriptor) {
    printf("LUIAtlasDescriptor ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUIAtlasDescriptor *local_this = (LUIAtlasDescriptor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUIAtlasDescriptor) {
    return local_this;
  }
  if (requested_type == &Dtool_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUIAtlasDescriptor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUIAtlasDescriptor) {
    return from_this;
  }
  if (from_type == &Dtool_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIAtlasDescriptor*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. LUIAtlasPacker
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LVector2f LUIAtlasPacker::find_position(int w, int h)
 *******************************************************************/
static PyObject *Dtool_LUIAtlasPacker_find_position_14(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIAtlasPacker *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIAtlasPacker, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-LVector2f LUIAtlasPacker::find_position(int w, int h)
    int param1;
    int param2;
    static char *keyword_list[] = {(char *)"w", (char *)"h", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:find_position", keyword_list, &param1, &param2)) {
      LVector2f result = (local_this)->find_position((int)param1, (int)param2);
      LVector2f *return_value = new LVector2f(result);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIAtlasPacker.find_position() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "find_position(LUIAtlasPacker this, int w, int h)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlasPacker_find_position_14_comment =
  "C++ Interface:\n"
  "find_position(LUIAtlasPacker this, int w, int h)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIAtlasPacker_find_position_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LUIAtlasPacker::LUIAtlasPacker(int size)
 *******************************************************************/
int Dtool_Init_LUIAtlasPacker(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-LUIAtlasPacker::LUIAtlasPacker(int size)
  int param0;
  static char *keyword_list[] = {(char *)"size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i:LUIAtlasPacker", keyword_list, &param0)) {
    LUIAtlasPacker *return_value = new LUIAtlasPacker((int)param0);
    return_value->ref();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return -1;
    }
#endif
    return DTool_PyInit_Finalize(self, return_value, &Dtool_LUIAtlasPacker, true, false);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "LUIAtlasPacker(int size)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_LUIAtlasPacker(PyObject *self, PyObject *args) {
  return Dtool_Init_LUIAtlasPacker(self, args, NULL);
}

inline void *Dtool_UpcastInterface_LUIAtlasPacker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUIAtlasPacker) {
    printf("LUIAtlasPacker ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUIAtlasPacker *local_this = (LUIAtlasPacker *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUIAtlasPacker) {
    return local_this;
  }
  if (requested_type == &Dtool_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUIAtlasPacker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUIAtlasPacker) {
    return from_this;
  }
  if (from_type == &Dtool_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIAtlasPacker*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. LUIAtlasPool
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static LUIAtlasPool *LUIAtlasPool::get_global_ptr(void)
 *******************************************************************/
static PyObject *Dtool_LUIAtlasPool_get_global_ptr_16(PyObject *) {

  // 1-static LUIAtlasPool *LUIAtlasPool::get_global_ptr(void)
  LUIAtlasPool *return_value = LUIAtlasPool::get_global_ptr();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    return (PyObject *)NULL;
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstance((void *)return_value, Dtool_LUIAtlasPool, false, false);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_global_ptr()\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlasPool_get_global_ptr_16_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "";
#else
static const char *Dtool_LUIAtlasPool_get_global_ptr_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LUIAtlasPool::load_atlas(basic_string< char > const &atlas_id, basic_string< char > const &atlas_desc_path, basic_string< char > const &atlas_tex_path)
 *******************************************************************/
static PyObject *Dtool_LUIAtlasPool_load_atlas_17(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIAtlasPool *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIAtlasPool, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void LUIAtlasPool::load_atlas(basic_string< char > const &atlas_id, basic_string< char > const &atlas_desc_path, basic_string< char > const &atlas_tex_path)
    char *param1_str;
    Py_ssize_t param1_len;
    char *param2_str;
    Py_ssize_t param2_len;
    char *param3_str;
    Py_ssize_t param3_len;
    static char *keyword_list[] = {(char *)"atlas_id", (char *)"atlas_desc_path", (char *)"atlas_tex_path", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#:load_atlas", keyword_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3_str, &param3_len)) {
      (local_this)->load_atlas(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIAtlasPool.load_atlas() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "load_atlas(LUIAtlasPool this, str atlas_id, str atlas_desc_path, str atlas_tex_path)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlasPool_load_atlas_17_comment =
  "C++ Interface:\n"
  "load_atlas(LUIAtlasPool this, str atlas_id, str atlas_desc_path, str atlas_tex_path)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIAtlasPool_load_atlas_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool LUIAtlasPool::has_atlas(basic_string< char > const &atlas_id)
 *******************************************************************/
static PyObject *Dtool_LUIAtlasPool_has_atlas_18(PyObject *self, PyObject *arg) {
  LUIAtlasPool *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIAtlasPool, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline bool LUIAtlasPool::has_atlas(basic_string< char > const &atlas_id)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      bool return_value = (local_this)->has_atlas(basic_string<char>(param1_str, param1_len));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      return PyBool_FromLong(return_value);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIAtlasPool.has_atlas() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "has_atlas(LUIAtlasPool this, str atlas_id)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlasPool_has_atlas_18_comment =
  "C++ Interface:\n"
  "has_atlas(LUIAtlasPool this, str atlas_id)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIAtlasPool_has_atlas_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< LUIAtlas > LUIAtlasPool::get_atlas(basic_string< char > const &atlas_id)
 *******************************************************************/
static PyObject *Dtool_LUIAtlasPool_get_atlas_19(PyObject *self, PyObject *arg) {
  LUIAtlasPool *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIAtlasPool, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline PointerTo< LUIAtlas > LUIAtlasPool::get_atlas(basic_string< char > const &atlas_id)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      PointerTo< LUIAtlas > return_value = (local_this)->get_atlas(basic_string<char>(param1_str, param1_len));
      if (return_value != (LUIAtlas *)0) {
        return_value->ref();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      if (return_value.p() == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value.p(), Dtool_LUIAtlas, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIAtlasPool.get_atlas() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_atlas(LUIAtlasPool this, str atlas_id)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlasPool_get_atlas_19_comment =
  "C++ Interface:\n"
  "get_atlas(LUIAtlasPool this, str atlas_id)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIAtlasPool_get_atlas_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< LUIAtlasDescriptor > LUIAtlasPool::get_descriptor(basic_string< char > const &entry_id)
 * inline PointerTo< LUIAtlasDescriptor > LUIAtlasPool::get_descriptor(basic_string< char > const &atlas_id, basic_string< char > const &entry_id)
 *******************************************************************/
static PyObject *Dtool_LUIAtlasPool_get_descriptor_20(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIAtlasPool *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIAtlasPool, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PointerTo< LUIAtlasDescriptor > LUIAtlasPool::get_descriptor(basic_string< char > const &entry_id)
      char *param1_str;
      Py_ssize_t param1_len;
      static char *keyword_list[] = {(char *)"entry_id", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:get_descriptor", keyword_list, &param1_str, &param1_len)) {
        PointerTo< LUIAtlasDescriptor > return_value = (local_this)->get_descriptor(basic_string<char>(param1_str, param1_len));
        if (return_value != (LUIAtlasDescriptor *)0) {
          return_value->ref();
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        if (return_value.p() == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstance((void *)return_value.p(), Dtool_LUIAtlasDescriptor, true, false);
        }
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUIAtlasPool.get_descriptor() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  case 2: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PointerTo< LUIAtlasDescriptor > LUIAtlasPool::get_descriptor(basic_string< char > const &atlas_id, basic_string< char > const &entry_id)
      char *param1_str;
      Py_ssize_t param1_len;
      char *param2_str;
      Py_ssize_t param2_len;
      static char *keyword_list[] = {(char *)"atlas_id", (char *)"entry_id", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:get_descriptor", keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
        PointerTo< LUIAtlasDescriptor > return_value = (local_this)->get_descriptor(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
        if (return_value != (LUIAtlasDescriptor *)0) {
          return_value->ref();
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        if (return_value.p() == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstance((void *)return_value.p(), Dtool_LUIAtlasDescriptor, true, false);
        }
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUIAtlasPool.get_descriptor() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "get_descriptor() takes 2 or 3 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "get_descriptor(LUIAtlasPool this, str entry_id)\n"
      "get_descriptor(LUIAtlasPool this, str atlas_id, str entry_id)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlasPool_get_descriptor_20_comment =
  "C++ Interface:\n"
  "get_descriptor(LUIAtlasPool this, str entry_id)\n"
  "get_descriptor(LUIAtlasPool this, str atlas_id, str entry_id)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIAtlasPool_get_descriptor_20_comment = NULL;
#endif

int Dtool_Init_LUIAtlasPool(PyObject *self, PyObject *args, PyObject *kwds) {
  PyErr_SetString(PyExc_TypeError, "cannot init constant class (LUIAtlasPool)");
  return -1;
}

int Dtool_InitNoCoerce_LUIAtlasPool(PyObject *self, PyObject *args) {
  PyErr_SetString(PyExc_TypeError, "cannot init constant class (LUIAtlasPool)");
  return -1;
}

inline void *Dtool_UpcastInterface_LUIAtlasPool(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUIAtlasPool) {
    printf("LUIAtlasPool ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUIAtlasPool *local_this = (LUIAtlasPool *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUIAtlasPool) {
    return local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUIAtlasPool(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUIAtlasPool) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. LUIBaseElement
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LUIBaseElement::set_top_left(float top, float left)
 *******************************************************************/
static PyObject *Dtool_LUIBaseElement_set_top_left_23(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBaseElement *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIBaseElement, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUIBaseElement::set_top_left(float top, float left)
    float param1;
    float param2;
    static char *keyword_list[] = {(char *)"top", (char *)"left", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_top_left", keyword_list, &param1, &param2)) {
      (local_this)->set_top_left((float)param1, (float)param2);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIBaseElement.set_top_left() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_top_left(LUIBaseElement this, float top, float left)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_top_left_23_comment =
  "C++ Interface:\n"
  "set_top_left(LUIBaseElement this, float top, float left)\n"
  "\n"
  "// Position\n"
  "";
#else
static const char *Dtool_LUIBaseElement_set_top_left_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUIBaseElement::set_top(float top)
 *******************************************************************/
static PyObject *Dtool_LUIBaseElement_set_top_24(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIBaseElement, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUIBaseElement::set_top(float top)
    if (PyNumber_Check(arg)) {
      (local_this)->set_top((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIBaseElement.set_top() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_top(LUIBaseElement this, float top)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_top_24_comment =
  "C++ Interface:\n"
  "set_top(LUIBaseElement this, float top)\n"
  "\n"
  "// Position\n"
  "";
#else
static const char *Dtool_LUIBaseElement_set_top_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUIBaseElement::set_bottom(float bottom)
 *******************************************************************/
static PyObject *Dtool_LUIBaseElement_set_bottom_25(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIBaseElement, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUIBaseElement::set_bottom(float bottom)
    if (PyNumber_Check(arg)) {
      (local_this)->set_bottom((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIBaseElement.set_bottom() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_bottom(LUIBaseElement this, float bottom)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_bottom_25_comment =
  "C++ Interface:\n"
  "set_bottom(LUIBaseElement this, float bottom)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIBaseElement_set_bottom_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUIBaseElement::set_left(float left)
 *******************************************************************/
static PyObject *Dtool_LUIBaseElement_set_left_26(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIBaseElement, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUIBaseElement::set_left(float left)
    if (PyNumber_Check(arg)) {
      (local_this)->set_left((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIBaseElement.set_left() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_left(LUIBaseElement this, float left)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_left_26_comment =
  "C++ Interface:\n"
  "set_left(LUIBaseElement this, float left)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIBaseElement_set_left_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUIBaseElement::set_right(float right)
 *******************************************************************/
static PyObject *Dtool_LUIBaseElement_set_right_27(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIBaseElement, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUIBaseElement::set_right(float right)
    if (PyNumber_Check(arg)) {
      (local_this)->set_right((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIBaseElement.set_right() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_right(LUIBaseElement this, float right)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_right_27_comment =
  "C++ Interface:\n"
  "set_right(LUIBaseElement this, float right)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIBaseElement_set_right_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUIBaseElement::set_size(LVector2f const &size)
 * inline void LUIBaseElement::set_size(float w, float h)
 *******************************************************************/
static PyObject *Dtool_LUIBaseElement_set_size_28(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBaseElement *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIBaseElement, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUIBaseElement::set_size(LVector2f const &size)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"size", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_size", keyword_list, &param1)) {
            LVector2f *param1_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector2f, 1, "LUIBaseElement.set_size", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_size(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUIBaseElement.set_size() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 2: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUIBaseElement::set_size(float w, float h)
      float param1;
      float param2;
      static char *keyword_list[] = {(char *)"w", (char *)"h", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_size", keyword_list, &param1, &param2)) {
        (local_this)->set_size((float)param1, (float)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUIBaseElement.set_size() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_size() takes 2 or 3 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_size(LUIBaseElement this, const LVector2f size)\n"
      "set_size(LUIBaseElement this, float w, float h)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_size_28_comment =
  "C++ Interface:\n"
  "set_size(LUIBaseElement this, const LVector2f size)\n"
  "set_size(LUIBaseElement this, float w, float h)\n"
  "\n"
  "// Size\n"
  "\n"
  "// Size\n"
  "";
#else
static const char *Dtool_LUIBaseElement_set_size_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUIBaseElement::set_width(float w)
 *******************************************************************/
static PyObject *Dtool_LUIBaseElement_set_width_29(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIBaseElement, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUIBaseElement::set_width(float w)
    if (PyNumber_Check(arg)) {
      (local_this)->set_width((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIBaseElement.set_width() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_width(LUIBaseElement this, float w)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_width_29_comment =
  "C++ Interface:\n"
  "set_width(LUIBaseElement this, float w)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIBaseElement_set_width_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUIBaseElement::set_height(float h)
 *******************************************************************/
static PyObject *Dtool_LUIBaseElement_set_height_30(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIBaseElement, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUIBaseElement::set_height(float h)
    if (PyNumber_Check(arg)) {
      (local_this)->set_height((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIBaseElement.set_height() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_height(LUIBaseElement this, float h)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_height_30_comment =
  "C++ Interface:\n"
  "set_height(LUIBaseElement this, float h)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIBaseElement_set_height_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f const &LUIBaseElement::get_size(void) const
 *******************************************************************/
static PyObject *Dtool_LUIBaseElement_get_size_31(PyObject *self) {
  LUIBaseElement *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIBaseElement, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  // 1-inline LVector2f const &LUIBaseElement::get_size(void) const
  LVector2f const *return_value = &(((const LUIBaseElement*)local_this)->get_size());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    return (PyObject *)NULL;
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, false, true);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_size(const LUIBaseElement this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_size_31_comment =
  "C++ Interface:\n"
  "get_size(const LUIBaseElement this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIBaseElement_get_size_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUIBaseElement::set_visible(bool visible)
 *******************************************************************/
static PyObject *Dtool_LUIBaseElement_set_visible_32(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIBaseElement, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUIBaseElement::set_visible(bool visible)
    (local_this)->set_visible((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIBaseElement.set_visible() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_visible(LUIBaseElement this, bool visible)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_visible_32_comment =
  "C++ Interface:\n"
  "set_visible(LUIBaseElement this, bool visible)\n"
  "\n"
  "// Visible\n"
  "";
#else
static const char *Dtool_LUIBaseElement_set_visible_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool LUIBaseElement::is_visible(void)
 *******************************************************************/
static PyObject *Dtool_LUIBaseElement_is_visible_33(PyObject *self) {
  LUIBaseElement *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIBaseElement, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline bool LUIBaseElement::is_visible(void)
    bool return_value = (local_this)->is_visible();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyBool_FromLong(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIBaseElement.is_visible() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "is_visible(LUIBaseElement this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_is_visible_33_comment =
  "C++ Interface:\n"
  "is_visible(LUIBaseElement this)\n"
  "\n"
  "// Visible\n"
  "";
#else
static const char *Dtool_LUIBaseElement_is_visible_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUIBaseElement::hide(void)
 *******************************************************************/
static PyObject *Dtool_LUIBaseElement_hide_34(PyObject *self) {
  LUIBaseElement *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIBaseElement, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUIBaseElement::hide(void)
    (local_this)->hide();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIBaseElement.hide() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "hide(LUIBaseElement this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_hide_34_comment =
  "C++ Interface:\n"
  "hide(LUIBaseElement this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIBaseElement_hide_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUIBaseElement::show(void)
 *******************************************************************/
static PyObject *Dtool_LUIBaseElement_show_35(PyObject *self) {
  LUIBaseElement *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIBaseElement, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUIBaseElement::show(void)
    (local_this)->show();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIBaseElement.show() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "show(LUIBaseElement this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_show_35_comment =
  "C++ Interface:\n"
  "show(LUIBaseElement this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIBaseElement_show_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LUISprite *LUIBaseElement::downcast_to_LUISprite(void)
 *******************************************************************/
static PyObject *Dtool_LUIBaseElement_downcast_to_LUISprite_50(PyObject *self) {
  LUIBaseElement *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIBaseElement, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-LUISprite *LUIBaseElement::downcast_to_LUISprite(void)
    LUISprite *return_value = (LUISprite *)local_this;
    return_value->ref();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_LUISprite, true, false);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIBaseElement.downcast_to_LUISprite() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "downcast_to_LUISprite(LUIBaseElement this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_downcast_to_LUISprite_50_comment =
  "C++ Interface:\n"
  "downcast_to_LUISprite(LUIBaseElement this)\n"
  "\n"
  "downcast from LUIBaseElement to LUISprite\n"
  "";
#else
static const char *Dtool_LUIBaseElement_downcast_to_LUISprite_50_comment = NULL;
#endif

int Dtool_Init_LUIBaseElement(PyObject *self, PyObject *args, PyObject *kwds) {
  PyErr_SetString(PyExc_TypeError, "cannot init constant class (LUIBaseElement)");
  return -1;
}

int Dtool_InitNoCoerce_LUIBaseElement(PyObject *self, PyObject *args) {
  PyErr_SetString(PyExc_TypeError, "cannot init constant class (LUIBaseElement)");
  return -1;
}

inline void *Dtool_UpcastInterface_LUIBaseElement(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUIBaseElement) {
    printf("LUIBaseElement ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUIBaseElement *local_this = (LUIBaseElement *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUIBaseElement) {
    return local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUIBaseElement(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUIBaseElement) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. LUINode
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< LUIAtlasDescriptor > LUINode::get_atlas_image(basic_string< char > const &identifier)
 * inline PointerTo< LUIAtlasDescriptor > LUINode::get_atlas_image(basic_string< char > const &atlas_id, basic_string< char > const &identifier)
 *******************************************************************/
static PyObject *Dtool_LUINode_get_atlas_image_38(PyObject *self, PyObject *args, PyObject *kwds) {
  LUINode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUINode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PointerTo< LUIAtlasDescriptor > LUINode::get_atlas_image(basic_string< char > const &identifier)
      char *param1_str;
      Py_ssize_t param1_len;
      static char *keyword_list[] = {(char *)"identifier", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:get_atlas_image", keyword_list, &param1_str, &param1_len)) {
        PointerTo< LUIAtlasDescriptor > return_value = (local_this)->get_atlas_image(basic_string<char>(param1_str, param1_len));
        if (return_value != (LUIAtlasDescriptor *)0) {
          return_value->ref();
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        if (return_value.p() == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstance((void *)return_value.p(), Dtool_LUIAtlasDescriptor, true, false);
        }
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUINode.get_atlas_image() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  case 2: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PointerTo< LUIAtlasDescriptor > LUINode::get_atlas_image(basic_string< char > const &atlas_id, basic_string< char > const &identifier)
      char *param1_str;
      Py_ssize_t param1_len;
      char *param2_str;
      Py_ssize_t param2_len;
      static char *keyword_list[] = {(char *)"atlas_id", (char *)"identifier", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:get_atlas_image", keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
        PointerTo< LUIAtlasDescriptor > return_value = (local_this)->get_atlas_image(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
        if (return_value != (LUIAtlasDescriptor *)0) {
          return_value->ref();
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        if (return_value.p() == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstance((void *)return_value.p(), Dtool_LUIAtlasDescriptor, true, false);
        }
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUINode.get_atlas_image() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "get_atlas_image() takes 2 or 3 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "get_atlas_image(LUINode this, str identifier)\n"
      "get_atlas_image(LUINode this, str atlas_id, str identifier)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUINode_get_atlas_image_38_comment =
  "C++ Interface:\n"
  "get_atlas_image(LUINode this, str identifier)\n"
  "get_atlas_image(LUINode this, str atlas_id, str identifier)\n"
  "\n"
  "";
#else
static const char *Dtool_LUINode_get_atlas_image_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< LUISprite > LUINode::attach_sprite(float x, float y, PointerTo< LUIAtlasDescriptor > desc)
 * inline PointerTo< LUISprite > LUINode::attach_sprite(float x, float y, PointerTo< Texture > tex)
 * inline PointerTo< LUISprite > LUINode::attach_sprite(float x, float y, basic_string< char > const &source)
 *******************************************************************/
static PyObject *Dtool_LUINode_attach_sprite_39(PyObject *self, PyObject *args, PyObject *kwds) {
  LUINode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUINode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 inline PointerTo< LUISprite > LUINode::attach_sprite(float x, float y, PointerTo< LUIAtlasDescriptor > desc)
        float param1;
        float param2;
        PyObject *param3;
        static char *keyword_list[] = {(char *)"x", (char *)"y", (char *)"desc", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:attach_sprite", keyword_list, &param1, &param2, &param3)) {
          LUIAtlasDescriptor *param3_this = (LUIAtlasDescriptor *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LUIAtlasDescriptor, 3, "LUINode.attach_sprite", 1, coerced_ptr, report_errors);

          if (param3_this != NULL) {
            PointerTo< LUISprite > return_value = (local_this)->attach_sprite((float)param1, (float)param2, param3_this);
            if (return_value != (LUISprite *)0) {
              return_value->ref();
            }
            Py_XDECREF(coerced);
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            if (return_value.p() == NULL) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstance((void *)return_value.p(), Dtool_LUISprite, true, false);
            }
          }
        }
        PyErr_Clear();
      }

      if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 inline PointerTo< LUISprite > LUINode::attach_sprite(float x, float y, PointerTo< Texture > tex)
        float param1;
        float param2;
        PyObject *param3;
        static char *keyword_list[] = {(char *)"x", (char *)"y", (char *)"tex", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:attach_sprite", keyword_list, &param1, &param2, &param3)) {
          Texture *param3_this = (Texture *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_Texture, 3, "LUINode.attach_sprite", 1, coerced_ptr, report_errors);

          if (param3_this != NULL) {
            PointerTo< LUISprite > return_value = (local_this)->attach_sprite((float)param1, (float)param2, param3_this);
            if (return_value != (LUISprite *)0) {
              return_value->ref();
            }
            Py_XDECREF(coerced);
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            if (return_value.p() == NULL) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstance((void *)return_value.p(), Dtool_LUISprite, true, false);
            }
          }
        }
        PyErr_Clear();
      }

      if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 inline PointerTo< LUISprite > LUINode::attach_sprite(float x, float y, basic_string< char > const &source)
        float param1;
        float param2;
        char *param3_str;
        Py_ssize_t param3_len;
        static char *keyword_list[] = {(char *)"x", (char *)"y", (char *)"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "ffs#:attach_sprite", keyword_list, &param1, &param2, &param3_str, &param3_len)) {
          PointerTo< LUISprite > return_value = (local_this)->attach_sprite((float)param1, (float)param2, basic_string<char>(param3_str, param3_len));
          if (return_value != (LUISprite *)0) {
            return_value->ref();
          }
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          if (return_value.p() == NULL) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstance((void *)return_value.p(), Dtool_LUISprite, true, false);
          }
        }
        PyErr_Clear();
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "attach_sprite(LUINode this, float x, float y, const LUIAtlasDescriptor desc)\n"
      "attach_sprite(LUINode this, float x, float y, const Texture tex)\n"
      "attach_sprite(LUINode this, float x, float y, str source)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUINode_attach_sprite_39_comment =
  "C++ Interface:\n"
  "attach_sprite(LUINode this, float x, float y, const LUIAtlasDescriptor desc)\n"
  "attach_sprite(LUINode this, float x, float y, const Texture tex)\n"
  "attach_sprite(LUINode this, float x, float y, str source)\n"
  "\n"
  "";
#else
static const char *Dtool_LUINode_attach_sprite_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUINode::remove_sprite(PointerTo< LUISprite > sprite)
 *******************************************************************/
static PyObject *Dtool_LUINode_remove_sprite_40(PyObject *self, PyObject *arg) {
  LUINode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUINode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void LUINode::remove_sprite(PointerTo< LUISprite > sprite)
        LUISprite *arg_this = (LUISprite *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LUISprite, 1, "LUINode.remove_sprite", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->remove_sprite(arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUINode.remove_sprite() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "remove_sprite(LUINode this, const LUISprite sprite)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUINode_remove_sprite_40_comment =
  "C++ Interface:\n"
  "remove_sprite(LUINode this, const LUISprite sprite)\n"
  "\n"
  "";
#else
static const char *Dtool_LUINode_remove_sprite_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int LUINode::get_sprite_count(void)
 *******************************************************************/
static PyObject *Dtool_LUINode_get_sprite_count_41(PyObject *self) {
  LUINode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUINode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline int LUINode::get_sprite_count(void)
    int return_value = (local_this)->get_sprite_count();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
#if PY_MAJOR_VERSION >= 3
    return PyLong_FromLong(return_value);
#else
    return PyInt_FromLong(return_value);
#endif
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUINode.get_sprite_count() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_sprite_count(LUINode this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUINode_get_sprite_count_41_comment =
  "C++ Interface:\n"
  "get_sprite_count(LUINode this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUINode_get_sprite_count_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< LUISprite > LUINode::get_sprite(int n)
 *******************************************************************/
static PyObject *Dtool_LUINode_get_sprite_42(PyObject *self, PyObject *arg) {
  LUINode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUINode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline PointerTo< LUISprite > LUINode::get_sprite(int n)
    if (PyInt_Check(arg)) {
      PointerTo< LUISprite > return_value = (local_this)->get_sprite((int)PyInt_AS_LONG(arg));
      if (return_value != (LUISprite *)0) {
        return_value->ref();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      if (return_value.p() == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value.p(), Dtool_LUISprite, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUINode.get_sprite() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_sprite(LUINode this, int n)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUINode_get_sprite_42_comment =
  "C++ Interface:\n"
  "get_sprite(LUINode this, int n)\n"
  "\n"
  "";
#else
static const char *Dtool_LUINode_get_sprite_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f const &LUINode::get_size(void) const
 *******************************************************************/
static PyObject *Dtool_LUINode_get_size_43(PyObject *self) {
  LUINode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUINode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  // 1-inline LVector2f const &LUINode::get_size(void) const
  LVector2f const *return_value = &(((const LUINode*)local_this)->get_size());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    return (PyObject *)NULL;
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, false, true);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_size(const LUINode this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUINode_get_size_43_comment =
  "C++ Interface:\n"
  "get_size(const LUINode this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUINode_get_size_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUINode::set_size(LVector2f const &size)
 * inline void LUINode::set_size(float w, float h)
 *******************************************************************/
static PyObject *Dtool_LUINode_set_size_44(PyObject *self, PyObject *args, PyObject *kwds) {
  LUINode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUINode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUINode::set_size(LVector2f const &size)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"size", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_size", keyword_list, &param1)) {
            LVector2f *param1_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector2f, 1, "LUINode.set_size", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_size(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUINode.set_size() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 2: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUINode::set_size(float w, float h)
      float param1;
      float param2;
      static char *keyword_list[] = {(char *)"w", (char *)"h", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_size", keyword_list, &param1, &param2)) {
        (local_this)->set_size((float)param1, (float)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUINode.set_size() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_size() takes 2 or 3 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_size(LUINode this, const LVector2f size)\n"
      "set_size(LUINode this, float w, float h)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUINode_set_size_44_comment =
  "C++ Interface:\n"
  "set_size(LUINode this, const LVector2f size)\n"
  "set_size(LUINode this, float w, float h)\n"
  "\n"
  "";
#else
static const char *Dtool_LUINode_set_size_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LUINode::operator +=(PointerTo< LUINode > node)
 *******************************************************************/
static PyObject *Dtool_LUINode_operator_45(PyObject *self, PyObject *arg) {
  LUINode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUINode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-void LUINode::operator +=(PointerTo< LUINode > node)
        LUINode *arg_this = (LUINode *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LUINode, 1, "LUINode.__iadd__", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->operator +=(arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(self);
          return self;
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUINode.__iadd__() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "__iadd__(LUINode this, const LUINode node)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUINode_operator_45_comment =
  "C++ Interface:\n"
  "__iadd__(LUINode this, const LUINode node)\n"
  "\n"
  "";
#else
static const char *Dtool_LUINode_operator_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LUINode::LUINode(float w, float h)
 *******************************************************************/
int Dtool_Init_LUINode(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-LUINode::LUINode(float w, float h)
  float param0;
  float param1;
  static char *keyword_list[] = {(char *)"w", (char *)"h", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:LUINode", keyword_list, &param0, &param1)) {
    LUINode *return_value = new LUINode((float)param0, (float)param1);
    return_value->ref();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return -1;
    }
#endif
    return DTool_PyInit_Finalize(self, return_value, &Dtool_LUINode, true, false);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "LUINode(float w, float h)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_LUINode(PyObject *self, PyObject *args) {
  return Dtool_Init_LUINode(self, args, NULL);
}

inline void *Dtool_UpcastInterface_LUINode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUINode) {
    printf("LUINode ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUINode *local_this = (LUINode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUINode) {
    return local_this;
  }
  if (requested_type == &Dtool_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUINode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUINode) {
    return from_this;
  }
  if (from_type == &Dtool_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUINode*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. LUISprite
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_texcoord_start(LVector2f const &texcoord_start)
 * inline void LUISprite::set_texcoord_start(float u, float v)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_texcoord_start_51(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUISprite::set_texcoord_start(LVector2f const &texcoord_start)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"texcoord_start", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_texcoord_start", keyword_list, &param1)) {
            LVector2f *param1_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector2f, 1, "LUISprite.set_texcoord_start", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_texcoord_start(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUISprite.set_texcoord_start() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 2: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUISprite::set_texcoord_start(float u, float v)
      float param1;
      float param2;
      static char *keyword_list[] = {(char *)"u", (char *)"v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_texcoord_start", keyword_list, &param1, &param2)) {
        (local_this)->set_texcoord_start((float)param1, (float)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUISprite.set_texcoord_start() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_texcoord_start() takes 2 or 3 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_texcoord_start(LUISprite this, const LVector2f texcoord_start)\n"
      "set_texcoord_start(LUISprite this, float u, float v)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_texcoord_start_51_comment =
  "C++ Interface:\n"
  "set_texcoord_start(LUISprite this, const LVector2f texcoord_start)\n"
  "set_texcoord_start(LUISprite this, float u, float v)\n"
  "\n"
  "// Texcoord\n"
  "\n"
  "// Texcoord\n"
  "";
#else
static const char *Dtool_LUISprite_set_texcoord_start_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f LUISprite::get_texcoord_start(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_texcoord_start_52(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVector2f LUISprite::get_texcoord_start(void)
    LVector2f result = (local_this)->get_texcoord_start();
    LVector2f *return_value = new LVector2f(result);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, true, false);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_texcoord_start() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_texcoord_start(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_texcoord_start_52_comment =
  "C++ Interface:\n"
  "get_texcoord_start(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_texcoord_start_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_texcoord_end(LVector2f const &texcoord_end)
 * inline void LUISprite::set_texcoord_end(float u, float v)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_texcoord_end_53(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUISprite::set_texcoord_end(LVector2f const &texcoord_end)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"texcoord_end", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_texcoord_end", keyword_list, &param1)) {
            LVector2f *param1_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector2f, 1, "LUISprite.set_texcoord_end", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_texcoord_end(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUISprite.set_texcoord_end() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 2: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUISprite::set_texcoord_end(float u, float v)
      float param1;
      float param2;
      static char *keyword_list[] = {(char *)"u", (char *)"v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_texcoord_end", keyword_list, &param1, &param2)) {
        (local_this)->set_texcoord_end((float)param1, (float)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUISprite.set_texcoord_end() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_texcoord_end() takes 2 or 3 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_texcoord_end(LUISprite this, const LVector2f texcoord_end)\n"
      "set_texcoord_end(LUISprite this, float u, float v)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_texcoord_end_53_comment =
  "C++ Interface:\n"
  "set_texcoord_end(LUISprite this, const LVector2f texcoord_end)\n"
  "set_texcoord_end(LUISprite this, float u, float v)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_texcoord_end_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f LUISprite::get_texcoord_end(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_texcoord_end_54(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVector2f LUISprite::get_texcoord_end(void)
    LVector2f result = (local_this)->get_texcoord_end();
    LVector2f *return_value = new LVector2f(result);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, true, false);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_texcoord_end() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_texcoord_end(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_texcoord_end_54_comment =
  "C++ Interface:\n"
  "get_texcoord_end(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_texcoord_end_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_color(LVecBase4f const &color)
 * inline void LUISprite::set_color(float r, float g, float b, float a)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_color_55(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUISprite::set_color(LVecBase4f const &color)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"color", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_color", keyword_list, &param1)) {
            LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "LUISprite.set_color", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_color(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUISprite.set_color() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 4: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUISprite::set_color(float r, float g, float b, float a)
      float param1;
      float param2;
      float param3;
      float param4;
      static char *keyword_list[] = {(char *)"r", (char *)"g", (char *)"b", (char *)"a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_color", keyword_list, &param1, &param2, &param3, &param4)) {
        (local_this)->set_color((float)param1, (float)param2, (float)param3, (float)param4);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUISprite.set_color() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_color() takes 2 or 5 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_color(LUISprite this, const LVecBase4f color)\n"
      "set_color(LUISprite this, float r, float g, float b, float a)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_color_55_comment =
  "C++ Interface:\n"
  "set_color(LUISprite this, const LVecBase4f color)\n"
  "set_color(LUISprite this, float r, float g, float b, float a)\n"
  "\n"
  "// Color\n"
  "\n"
  "// Color\n"
  "";
#else
static const char *Dtool_LUISprite_set_color_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f LUISprite::get_color(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_color_56(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase4f LUISprite::get_color(void)
    LVecBase4f result = (local_this)->get_color();
    LVecBase4f *return_value = new LVecBase4f(result);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase4f, true, false);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_color() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_color(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_color_56_comment =
  "C++ Interface:\n"
  "get_color(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_color_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_texture(LUIAtlasDescriptor *descriptor)
 * inline void LUISprite::set_texture(Texture *tex)
 * inline void LUISprite::set_texture(basic_string< char > const &source)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_texture_57(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 inline void LUISprite::set_texture(LUIAtlasDescriptor *descriptor)
        LUIAtlasDescriptor *arg_this = (LUIAtlasDescriptor *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LUIAtlasDescriptor, 1, "LUISprite.set_texture", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_texture(arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
        PyErr_Clear();
      }

      if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 inline void LUISprite::set_texture(Texture *tex)
        Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_Texture, 1, "LUISprite.set_texture", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_texture(arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
        PyErr_Clear();
      }

      if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 inline void LUISprite::set_texture(basic_string< char > const &source)
        char *param1_str;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
          param1_str = NULL;
        }
#endif
        if (param1_str != NULL) {
          (local_this)->set_texture(basic_string<char>(param1_str, param1_len));
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
        PyErr_Clear();
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_texture(LUISprite this, LUIAtlasDescriptor descriptor)\n"
      "set_texture(LUISprite this, Texture tex)\n"
      "set_texture(LUISprite this, str source)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_texture_57_comment =
  "C++ Interface:\n"
  "set_texture(LUISprite this, LUIAtlasDescriptor descriptor)\n"
  "set_texture(LUISprite this, Texture tex)\n"
  "set_texture(LUISprite this, str source)\n"
  "\n"
  "// Texture\n"
  "\n"
  "// Texture\n"
  "";
#else
static const char *Dtool_LUISprite_set_texture_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Texture *LUISprite::get_texture(void) const
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_texture_58(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  // 1-inline Texture *LUISprite::get_texture(void) const
  Texture *return_value = ((const LUISprite*)local_this)->get_texture();
  if (return_value != (Texture *)0) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    return (PyObject *)NULL;
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_Texture, true, false, (return_value)->as_typed_object()->get_type_index());
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_texture(const LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_texture_58_comment =
  "C++ Interface:\n"
  "get_texture(const LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_texture_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_z_index(float z_index)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_z_index_59(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_z_index(float z_index)
    if (PyNumber_Check(arg)) {
      (local_this)->set_z_index((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_z_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_z_index(LUISprite this, float z_index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_z_index_59_comment =
  "C++ Interface:\n"
  "set_z_index(LUISprite this, float z_index)\n"
  "\n"
  "// Z-Index\n"
  "";
#else
static const char *Dtool_LUISprite_set_z_index_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LUISprite::get_z_index(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_z_index_60(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float LUISprite::get_z_index(void)
    float return_value = (local_this)->get_z_index();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyFloat_FromDouble(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_z_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_z_index(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_z_index_60_comment =
  "C++ Interface:\n"
  "get_z_index(LUISprite this)\n"
  "\n"
  "// Z-Index\n"
  "";
#else
static const char *Dtool_LUISprite_get_z_index_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ReferenceCount *LUISprite::upcast_to_ReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_upcast_to_ReferenceCount_47(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-ReferenceCount *LUISprite::upcast_to_ReferenceCount(void)
    ReferenceCount *return_value = (ReferenceCount *)local_this;
    return_value->ref();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_ReferenceCount, true, false);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.upcast_to_ReferenceCount() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "upcast_to_ReferenceCount(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_upcast_to_ReferenceCount_47_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(LUISprite this)\n"
  "\n"
  "upcast from LUISprite to ReferenceCount\n"
  "";
#else
static const char *Dtool_LUISprite_upcast_to_ReferenceCount_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LUIBaseElement *LUISprite::upcast_to_LUIBaseElement(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_upcast_to_LUIBaseElement_49(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-LUIBaseElement *LUISprite::upcast_to_LUIBaseElement(void)
    LUIBaseElement *return_value = (LUIBaseElement *)local_this;
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_LUIBaseElement, false, false);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.upcast_to_LUIBaseElement() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "upcast_to_LUIBaseElement(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_upcast_to_LUIBaseElement_49_comment =
  "C++ Interface:\n"
  "upcast_to_LUIBaseElement(LUISprite this)\n"
  "\n"
  "upcast from LUISprite to LUIBaseElement\n"
  "";
#else
static const char *Dtool_LUISprite_upcast_to_LUIBaseElement_49_comment = NULL;
#endif

int Dtool_Init_LUISprite(PyObject *self, PyObject *args, PyObject *kwds) {
  PyErr_SetString(PyExc_TypeError, "cannot init constant class (LUISprite)");
  return -1;
}

int Dtool_InitNoCoerce_LUISprite(PyObject *self, PyObject *args) {
  PyErr_SetString(PyExc_TypeError, "cannot init constant class (LUISprite)");
  return -1;
}

inline void *Dtool_UpcastInterface_LUISprite(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUISprite) {
    printf("LUISprite ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUISprite *local_this = (LUISprite *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUISprite) {
    return local_this;
  }
  if (requested_type == &Dtool_LUIBaseElement) {
    return (LUIBaseElement *) local_this;
  }
  if (requested_type == &Dtool_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUISprite(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUISprite) {
    return from_this;
  }
  if (from_type == &Dtool_LUIBaseElement) {
    LUIBaseElement* other_this = (LUIBaseElement*)from_this;
    return (LUISprite*)other_this;
  }
  if (from_type == &Dtool_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUISprite*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. LUIRoot
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * PointerTo< LUISprite > LUIRoot::attach_sprite(float x, float y, LUIAtlasDescriptor *desc)
 *******************************************************************/
static PyObject *Dtool_LUIRoot_attach_sprite_65(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIRoot *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIRoot, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-PointerTo< LUISprite > LUIRoot::attach_sprite(float x, float y, LUIAtlasDescriptor *desc)
        float param1;
        float param2;
        PyObject *param3;
        static char *keyword_list[] = {(char *)"x", (char *)"y", (char *)"desc", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:attach_sprite", keyword_list, &param1, &param2, &param3)) {
          LUIAtlasDescriptor *param3_this = (LUIAtlasDescriptor *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LUIAtlasDescriptor, 3, "LUIRoot.attach_sprite", 0, coerced_ptr, report_errors);

          if (param3_this != NULL) {
            PointerTo< LUISprite > return_value = (local_this)->attach_sprite((float)param1, (float)param2, param3_this);
            if (return_value != (LUISprite *)0) {
              return_value->ref();
            }
            Py_XDECREF(coerced);
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            if (return_value.p() == NULL) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstance((void *)return_value.p(), Dtool_LUISprite, true, false);
            }
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUIRoot.attach_sprite() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "attach_sprite(LUIRoot this, float x, float y, LUIAtlasDescriptor desc)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIRoot_attach_sprite_65_comment =
  "C++ Interface:\n"
  "attach_sprite(LUIRoot this, float x, float y, LUIAtlasDescriptor desc)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIRoot_attach_sprite_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LUIRoot::operator +=(PointerTo< LUINode > node)
 *******************************************************************/
static PyObject *Dtool_LUIRoot_operator_66(PyObject *self, PyObject *arg) {
  LUIRoot *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIRoot, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-void LUIRoot::operator +=(PointerTo< LUINode > node)
        LUINode *arg_this = (LUINode *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LUINode, 1, "LUIRoot.__iadd__", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->operator +=(arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(self);
          return self;
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUIRoot.__iadd__() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "__iadd__(LUIRoot this, const LUINode node)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIRoot_operator_66_comment =
  "C++ Interface:\n"
  "__iadd__(LUIRoot this, const LUINode node)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIRoot_operator_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LUIRoot::LUIRoot(void)
 *******************************************************************/
int Dtool_Init_LUIRoot(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-LUIRoot::LUIRoot(void)
  LUIRoot *return_value = new LUIRoot();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    delete return_value;
    return -1;
  }
#endif
  return DTool_PyInit_Finalize(self, return_value, &Dtool_LUIRoot, true, false);

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "LUIRoot()\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_LUIRoot(PyObject *self, PyObject *args) {
  return Dtool_Init_LUIRoot(self, args, NULL);
}

inline void *Dtool_UpcastInterface_LUIRoot(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUIRoot) {
    printf("LUIRoot ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUIRoot *local_this = (LUIRoot *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUIRoot) {
    return local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUIRoot(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUIRoot) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Py Init Code For .. LUIAtlas | LUIAtlas
//********************************************************************
PyMethodDef Dtool_Methods_LUIAtlas[] = {
  { "load_descriptor_file", (PyCFunction) &Dtool_LUIAtlas_load_descriptor_file_4, METH_O, (char *) Dtool_LUIAtlas_load_descriptor_file_4_comment},
  { "loadDescriptorFile", (PyCFunction) &Dtool_LUIAtlas_load_descriptor_file_4, METH_O, (char *) Dtool_LUIAtlas_load_descriptor_file_4_comment},
  { "load_texture", (PyCFunction) &Dtool_LUIAtlas_load_texture_5, METH_O, (char *) Dtool_LUIAtlas_load_texture_5_comment},
  { "loadTexture", (PyCFunction) &Dtool_LUIAtlas_load_texture_5, METH_O, (char *) Dtool_LUIAtlas_load_texture_5_comment},
  { "get_texture", (PyCFunction) &Dtool_LUIAtlas_get_texture_6, METH_NOARGS, (char *) Dtool_LUIAtlas_get_texture_6_comment},
  { "getTexture", (PyCFunction) &Dtool_LUIAtlas_get_texture_6, METH_NOARGS, (char *) Dtool_LUIAtlas_get_texture_6_comment},
  { "has_entry", (PyCFunction) &Dtool_LUIAtlas_has_entry_7, METH_O, (char *) Dtool_LUIAtlas_has_entry_7_comment},
  { "hasEntry", (PyCFunction) &Dtool_LUIAtlas_has_entry_7, METH_O, (char *) Dtool_LUIAtlas_has_entry_7_comment},
  { "get_size", (PyCFunction) &Dtool_LUIAtlas_get_size_9, METH_NOARGS, (char *) Dtool_LUIAtlas_get_size_9_comment},
  { "getSize", (PyCFunction) &Dtool_LUIAtlas_get_size_9, METH_NOARGS, (char *) Dtool_LUIAtlas_get_size_9_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_LUIAtlas(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ReferenceCount._Dtool_ClassInit(NULL);
    Dtool_LUIAtlas.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_ReferenceCount.As_PyTypeObject());
    Dtool_LUIAtlas.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUIAtlas.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUIAtlas.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_LUIAtlas.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUIAtlas)");
      printf("Error in PyType_Ready(LUIAtlas)");
      return;
    }
    Py_INCREF(&Dtool_LUIAtlas.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUIAtlas, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUIAtlas.As_PyTypeObject());
    PyModule_AddObject(module, "LUIAtlas", (PyObject *)&Dtool_LUIAtlas.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. LUIAtlasDescriptor | LUIAtlasDescriptor
//********************************************************************
PyMethodDef Dtool_Methods_LUIAtlasDescriptor[] = {
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_LUIAtlasDescriptor(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ReferenceCount._Dtool_ClassInit(NULL);
    Dtool_LUIAtlasDescriptor.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_ReferenceCount.As_PyTypeObject());
    Dtool_LUIAtlasDescriptor.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUIAtlasDescriptor.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUIAtlasDescriptor.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_LUIAtlasDescriptor.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUIAtlasDescriptor)");
      printf("Error in PyType_Ready(LUIAtlasDescriptor)");
      return;
    }
    Py_INCREF(&Dtool_LUIAtlasDescriptor.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUIAtlasDescriptor, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUIAtlasDescriptor.As_PyTypeObject());
    PyModule_AddObject(module, "LUIAtlasDescriptor", (PyObject *)&Dtool_LUIAtlasDescriptor.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. LUIAtlasPacker | LUIAtlasPacker
//********************************************************************
PyMethodDef Dtool_Methods_LUIAtlasPacker[] = {
  { "find_position", (PyCFunction) &Dtool_LUIAtlasPacker_find_position_14, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIAtlasPacker_find_position_14_comment},
  { "findPosition", (PyCFunction) &Dtool_LUIAtlasPacker_find_position_14, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIAtlasPacker_find_position_14_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_LUIAtlasPacker(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ReferenceCount._Dtool_ClassInit(NULL);
    Dtool_LUIAtlasPacker.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_ReferenceCount.As_PyTypeObject());
    Dtool_LUIAtlasPacker.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUIAtlasPacker.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUIAtlasPacker.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_LUIAtlasPacker.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUIAtlasPacker)");
      printf("Error in PyType_Ready(LUIAtlasPacker)");
      return;
    }
    Py_INCREF(&Dtool_LUIAtlasPacker.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUIAtlasPacker, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUIAtlasPacker.As_PyTypeObject());
    PyModule_AddObject(module, "LUIAtlasPacker", (PyObject *)&Dtool_LUIAtlasPacker.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. LUIAtlasPool | LUIAtlasPool
//********************************************************************
PyMethodDef Dtool_Methods_LUIAtlasPool[] = {
  { "get_global_ptr", (PyCFunction) &Dtool_LUIAtlasPool_get_global_ptr_16, METH_NOARGS | METH_STATIC, (char *) Dtool_LUIAtlasPool_get_global_ptr_16_comment},
  { "getGlobalPtr", (PyCFunction) &Dtool_LUIAtlasPool_get_global_ptr_16, METH_NOARGS | METH_STATIC, (char *) Dtool_LUIAtlasPool_get_global_ptr_16_comment},
  { "load_atlas", (PyCFunction) &Dtool_LUIAtlasPool_load_atlas_17, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIAtlasPool_load_atlas_17_comment},
  { "loadAtlas", (PyCFunction) &Dtool_LUIAtlasPool_load_atlas_17, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIAtlasPool_load_atlas_17_comment},
  { "has_atlas", (PyCFunction) &Dtool_LUIAtlasPool_has_atlas_18, METH_O, (char *) Dtool_LUIAtlasPool_has_atlas_18_comment},
  { "hasAtlas", (PyCFunction) &Dtool_LUIAtlasPool_has_atlas_18, METH_O, (char *) Dtool_LUIAtlasPool_has_atlas_18_comment},
  { "get_atlas", (PyCFunction) &Dtool_LUIAtlasPool_get_atlas_19, METH_O, (char *) Dtool_LUIAtlasPool_get_atlas_19_comment},
  { "getAtlas", (PyCFunction) &Dtool_LUIAtlasPool_get_atlas_19, METH_O, (char *) Dtool_LUIAtlasPool_get_atlas_19_comment},
  { "get_descriptor", (PyCFunction) &Dtool_LUIAtlasPool_get_descriptor_20, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIAtlasPool_get_descriptor_20_comment},
  { "getDescriptor", (PyCFunction) &Dtool_LUIAtlasPool_get_descriptor_20, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIAtlasPool_get_descriptor_20_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_LUIAtlasPool(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DTOOL_SUPER_BASE._Dtool_ClassInit(NULL);
    Dtool_LUIAtlasPool.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DTOOL_SUPER_BASE.As_PyTypeObject());
    Dtool_LUIAtlasPool.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUIAtlasPool.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUIAtlasPool.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_LUIAtlasPool.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUIAtlasPool)");
      printf("Error in PyType_Ready(LUIAtlasPool)");
      return;
    }
    Py_INCREF(&Dtool_LUIAtlasPool.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUIAtlasPool, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUIAtlasPool.As_PyTypeObject());
    PyModule_AddObject(module, "LUIAtlasPool", (PyObject *)&Dtool_LUIAtlasPool.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. LUIBaseElement | LUIBaseElement
//********************************************************************
PyMethodDef Dtool_Methods_LUIBaseElement[] = {
  { "set_top_left", (PyCFunction) &Dtool_LUIBaseElement_set_top_left_23, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIBaseElement_set_top_left_23_comment},
  { "setTopLeft", (PyCFunction) &Dtool_LUIBaseElement_set_top_left_23, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIBaseElement_set_top_left_23_comment},
  { "set_top", (PyCFunction) &Dtool_LUIBaseElement_set_top_24, METH_O, (char *) Dtool_LUIBaseElement_set_top_24_comment},
  { "setTop", (PyCFunction) &Dtool_LUIBaseElement_set_top_24, METH_O, (char *) Dtool_LUIBaseElement_set_top_24_comment},
  { "set_bottom", (PyCFunction) &Dtool_LUIBaseElement_set_bottom_25, METH_O, (char *) Dtool_LUIBaseElement_set_bottom_25_comment},
  { "setBottom", (PyCFunction) &Dtool_LUIBaseElement_set_bottom_25, METH_O, (char *) Dtool_LUIBaseElement_set_bottom_25_comment},
  { "set_left", (PyCFunction) &Dtool_LUIBaseElement_set_left_26, METH_O, (char *) Dtool_LUIBaseElement_set_left_26_comment},
  { "setLeft", (PyCFunction) &Dtool_LUIBaseElement_set_left_26, METH_O, (char *) Dtool_LUIBaseElement_set_left_26_comment},
  { "set_right", (PyCFunction) &Dtool_LUIBaseElement_set_right_27, METH_O, (char *) Dtool_LUIBaseElement_set_right_27_comment},
  { "setRight", (PyCFunction) &Dtool_LUIBaseElement_set_right_27, METH_O, (char *) Dtool_LUIBaseElement_set_right_27_comment},
  { "set_size", (PyCFunction) &Dtool_LUIBaseElement_set_size_28, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIBaseElement_set_size_28_comment},
  { "setSize", (PyCFunction) &Dtool_LUIBaseElement_set_size_28, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIBaseElement_set_size_28_comment},
  { "set_width", (PyCFunction) &Dtool_LUIBaseElement_set_width_29, METH_O, (char *) Dtool_LUIBaseElement_set_width_29_comment},
  { "setWidth", (PyCFunction) &Dtool_LUIBaseElement_set_width_29, METH_O, (char *) Dtool_LUIBaseElement_set_width_29_comment},
  { "set_height", (PyCFunction) &Dtool_LUIBaseElement_set_height_30, METH_O, (char *) Dtool_LUIBaseElement_set_height_30_comment},
  { "setHeight", (PyCFunction) &Dtool_LUIBaseElement_set_height_30, METH_O, (char *) Dtool_LUIBaseElement_set_height_30_comment},
  { "get_size", (PyCFunction) &Dtool_LUIBaseElement_get_size_31, METH_NOARGS, (char *) Dtool_LUIBaseElement_get_size_31_comment},
  { "getSize", (PyCFunction) &Dtool_LUIBaseElement_get_size_31, METH_NOARGS, (char *) Dtool_LUIBaseElement_get_size_31_comment},
  { "set_visible", (PyCFunction) &Dtool_LUIBaseElement_set_visible_32, METH_O, (char *) Dtool_LUIBaseElement_set_visible_32_comment},
  { "setVisible", (PyCFunction) &Dtool_LUIBaseElement_set_visible_32, METH_O, (char *) Dtool_LUIBaseElement_set_visible_32_comment},
  { "is_visible", (PyCFunction) &Dtool_LUIBaseElement_is_visible_33, METH_NOARGS, (char *) Dtool_LUIBaseElement_is_visible_33_comment},
  { "isVisible", (PyCFunction) &Dtool_LUIBaseElement_is_visible_33, METH_NOARGS, (char *) Dtool_LUIBaseElement_is_visible_33_comment},
  { "hide", (PyCFunction) &Dtool_LUIBaseElement_hide_34, METH_NOARGS, (char *) Dtool_LUIBaseElement_hide_34_comment},
  { "show", (PyCFunction) &Dtool_LUIBaseElement_show_35, METH_NOARGS, (char *) Dtool_LUIBaseElement_show_35_comment},
  { "downcast_to_LUISprite", (PyCFunction) &Dtool_LUIBaseElement_downcast_to_LUISprite_50, METH_NOARGS, (char *) Dtool_LUIBaseElement_downcast_to_LUISprite_50_comment},
  { "downcastToLUISprite", (PyCFunction) &Dtool_LUIBaseElement_downcast_to_LUISprite_50, METH_NOARGS, (char *) Dtool_LUIBaseElement_downcast_to_LUISprite_50_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_LUIBaseElement(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DTOOL_SUPER_BASE._Dtool_ClassInit(NULL);
    Dtool_LUIBaseElement.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DTOOL_SUPER_BASE.As_PyTypeObject());
    Dtool_LUIBaseElement.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUIBaseElement.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUIBaseElement.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_LUIBaseElement.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUIBaseElement)");
      printf("Error in PyType_Ready(LUIBaseElement)");
      return;
    }
    Py_INCREF(&Dtool_LUIBaseElement.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUIBaseElement, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUIBaseElement.As_PyTypeObject());
    PyModule_AddObject(module, "LUIBaseElement", (PyObject *)&Dtool_LUIBaseElement.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. LUINode | LUINode
//********************************************************************
PyMethodDef Dtool_Methods_LUINode[] = {
  { "get_atlas_image", (PyCFunction) &Dtool_LUINode_get_atlas_image_38, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUINode_get_atlas_image_38_comment},
  { "getAtlasImage", (PyCFunction) &Dtool_LUINode_get_atlas_image_38, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUINode_get_atlas_image_38_comment},
  { "attach_sprite", (PyCFunction) &Dtool_LUINode_attach_sprite_39, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUINode_attach_sprite_39_comment},
  { "attachSprite", (PyCFunction) &Dtool_LUINode_attach_sprite_39, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUINode_attach_sprite_39_comment},
  { "remove_sprite", (PyCFunction) &Dtool_LUINode_remove_sprite_40, METH_O, (char *) Dtool_LUINode_remove_sprite_40_comment},
  { "removeSprite", (PyCFunction) &Dtool_LUINode_remove_sprite_40, METH_O, (char *) Dtool_LUINode_remove_sprite_40_comment},
  { "get_sprite_count", (PyCFunction) &Dtool_LUINode_get_sprite_count_41, METH_NOARGS, (char *) Dtool_LUINode_get_sprite_count_41_comment},
  { "getSpriteCount", (PyCFunction) &Dtool_LUINode_get_sprite_count_41, METH_NOARGS, (char *) Dtool_LUINode_get_sprite_count_41_comment},
  { "get_sprite", (PyCFunction) &Dtool_LUINode_get_sprite_42, METH_O, (char *) Dtool_LUINode_get_sprite_42_comment},
  { "getSprite", (PyCFunction) &Dtool_LUINode_get_sprite_42, METH_O, (char *) Dtool_LUINode_get_sprite_42_comment},
  { "get_size", (PyCFunction) &Dtool_LUINode_get_size_43, METH_NOARGS, (char *) Dtool_LUINode_get_size_43_comment},
  { "getSize", (PyCFunction) &Dtool_LUINode_get_size_43, METH_NOARGS, (char *) Dtool_LUINode_get_size_43_comment},
  { "set_size", (PyCFunction) &Dtool_LUINode_set_size_44, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUINode_set_size_44_comment},
  { "setSize", (PyCFunction) &Dtool_LUINode_set_size_44, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUINode_set_size_44_comment},
  { "__iadd__", (PyCFunction) &Dtool_LUINode_operator_45, METH_O, (char *) Dtool_LUINode_operator_45_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions.
//     LUINode ...tp_as_number->nb_inplace_add = __iadd__
//////////////////
static PyObject *Dtool_LUINode_operator_45__iadd__(PyObject *self, PyObject *arg) {
  return Dtool_LUINode_operator_45(self, arg);
}

void Dtool_PyModuleClassInit_LUINode(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ReferenceCount._Dtool_ClassInit(NULL);
    Dtool_LUINode.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_ReferenceCount.As_PyTypeObject());
    Dtool_LUINode.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUINode.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUINode.As_PyTypeObject().tp_dict);
#if PY_VERSION_HEX >= 0x2000000
    // tp_as_number->nb_inplace_add = __iadd__
    Dtool_LUINode.As_PyTypeObject().tp_as_number->nb_inplace_add = &Dtool_LUINode_operator_45__iadd__;
#endif
    if (PyType_Ready(&Dtool_LUINode.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUINode)");
      printf("Error in PyType_Ready(LUINode)");
      return;
    }
    Py_INCREF(&Dtool_LUINode.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUINode, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUINode.As_PyTypeObject());
    PyModule_AddObject(module, "LUINode", (PyObject *)&Dtool_LUINode.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. LUISprite | LUISprite
//********************************************************************
PyMethodDef Dtool_Methods_LUISprite[] = {
  { "set_texcoord_start", (PyCFunction) &Dtool_LUISprite_set_texcoord_start_51, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_texcoord_start_51_comment},
  { "setTexcoordStart", (PyCFunction) &Dtool_LUISprite_set_texcoord_start_51, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_texcoord_start_51_comment},
  { "get_texcoord_start", (PyCFunction) &Dtool_LUISprite_get_texcoord_start_52, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_start_52_comment},
  { "getTexcoordStart", (PyCFunction) &Dtool_LUISprite_get_texcoord_start_52, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_start_52_comment},
  { "set_texcoord_end", (PyCFunction) &Dtool_LUISprite_set_texcoord_end_53, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_texcoord_end_53_comment},
  { "setTexcoordEnd", (PyCFunction) &Dtool_LUISprite_set_texcoord_end_53, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_texcoord_end_53_comment},
  { "get_texcoord_end", (PyCFunction) &Dtool_LUISprite_get_texcoord_end_54, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_end_54_comment},
  { "getTexcoordEnd", (PyCFunction) &Dtool_LUISprite_get_texcoord_end_54, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_end_54_comment},
  { "set_color", (PyCFunction) &Dtool_LUISprite_set_color_55, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_color_55_comment},
  { "setColor", (PyCFunction) &Dtool_LUISprite_set_color_55, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_color_55_comment},
  { "get_color", (PyCFunction) &Dtool_LUISprite_get_color_56, METH_NOARGS, (char *) Dtool_LUISprite_get_color_56_comment},
  { "getColor", (PyCFunction) &Dtool_LUISprite_get_color_56, METH_NOARGS, (char *) Dtool_LUISprite_get_color_56_comment},
  { "set_texture", (PyCFunction) &Dtool_LUISprite_set_texture_57, METH_O, (char *) Dtool_LUISprite_set_texture_57_comment},
  { "setTexture", (PyCFunction) &Dtool_LUISprite_set_texture_57, METH_O, (char *) Dtool_LUISprite_set_texture_57_comment},
  { "get_texture", (PyCFunction) &Dtool_LUISprite_get_texture_58, METH_NOARGS, (char *) Dtool_LUISprite_get_texture_58_comment},
  { "getTexture", (PyCFunction) &Dtool_LUISprite_get_texture_58, METH_NOARGS, (char *) Dtool_LUISprite_get_texture_58_comment},
  { "set_z_index", (PyCFunction) &Dtool_LUISprite_set_z_index_59, METH_O, (char *) Dtool_LUISprite_set_z_index_59_comment},
  { "setZIndex", (PyCFunction) &Dtool_LUISprite_set_z_index_59, METH_O, (char *) Dtool_LUISprite_set_z_index_59_comment},
  { "get_z_index", (PyCFunction) &Dtool_LUISprite_get_z_index_60, METH_NOARGS, (char *) Dtool_LUISprite_get_z_index_60_comment},
  { "getZIndex", (PyCFunction) &Dtool_LUISprite_get_z_index_60, METH_NOARGS, (char *) Dtool_LUISprite_get_z_index_60_comment},
  { "upcast_to_ReferenceCount", (PyCFunction) &Dtool_LUISprite_upcast_to_ReferenceCount_47, METH_NOARGS, (char *) Dtool_LUISprite_upcast_to_ReferenceCount_47_comment},
  { "upcastToReferenceCount", (PyCFunction) &Dtool_LUISprite_upcast_to_ReferenceCount_47, METH_NOARGS, (char *) Dtool_LUISprite_upcast_to_ReferenceCount_47_comment},
  { "upcast_to_LUIBaseElement", (PyCFunction) &Dtool_LUISprite_upcast_to_LUIBaseElement_49, METH_NOARGS, (char *) Dtool_LUISprite_upcast_to_LUIBaseElement_49_comment},
  { "upcastToLUIBaseElement", (PyCFunction) &Dtool_LUISprite_upcast_to_LUIBaseElement_49, METH_NOARGS, (char *) Dtool_LUISprite_upcast_to_LUIBaseElement_49_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_LUISprite(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
#ifndef NDEBUG
    // Class documentation string
    Dtool_LUISprite.As_PyTypeObject().tp_doc =
      "////////////////////////////////////////////////////////////////////\n"
      "//       Class : LUISprite\n"
      "// Description : A LUISprite stores a single card, including position,\n"
      "//               scale, and uv coordinates. It also notifies the\n"
      "//               LUIVertexPool when any scalar or texture got changed.\n"
      "////////////////////////////////////////////////////////////////////";
#endif
    // Dependent objects
    Dtool_ReferenceCount._Dtool_ClassInit(NULL);
    Dtool_LUIBaseElement._Dtool_ClassInit(NULL);
    Dtool_LUISprite.As_PyTypeObject().tp_bases = PyTuple_Pack(2, &Dtool_ReferenceCount.As_PyTypeObject(), &Dtool_LUIBaseElement.As_PyTypeObject());
    Dtool_LUISprite.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUISprite.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUISprite.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_LUISprite.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUISprite)");
      printf("Error in PyType_Ready(LUISprite)");
      return;
    }
    Py_INCREF(&Dtool_LUISprite.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUISprite, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUISprite.As_PyTypeObject());
    PyModule_AddObject(module, "LUISprite", (PyObject *)&Dtool_LUISprite.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. LUIRoot | LUIRoot
//********************************************************************
PyMethodDef Dtool_Methods_LUIRoot[] = {
  { "attach_sprite", (PyCFunction) &Dtool_LUIRoot_attach_sprite_65, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIRoot_attach_sprite_65_comment},
  { "attachSprite", (PyCFunction) &Dtool_LUIRoot_attach_sprite_65, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIRoot_attach_sprite_65_comment},
  { "__iadd__", (PyCFunction) &Dtool_LUIRoot_operator_66, METH_O, (char *) Dtool_LUIRoot_operator_66_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions.
//     LUIRoot ...tp_as_number->nb_inplace_add = __iadd__
//////////////////
static PyObject *Dtool_LUIRoot_operator_66__iadd__(PyObject *self, PyObject *arg) {
  return Dtool_LUIRoot_operator_66(self, arg);
}

void Dtool_PyModuleClassInit_LUIRoot(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DTOOL_SUPER_BASE._Dtool_ClassInit(NULL);
    Dtool_LUIRoot.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DTOOL_SUPER_BASE.As_PyTypeObject());
    Dtool_LUIRoot.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUIRoot.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUIRoot.As_PyTypeObject().tp_dict);
#if PY_VERSION_HEX >= 0x2000000
    // tp_as_number->nb_inplace_add = __iadd__
    Dtool_LUIRoot.As_PyTypeObject().tp_as_number->nb_inplace_add = &Dtool_LUIRoot_operator_66__iadd__;
#endif
    if (PyType_Ready(&Dtool_LUIRoot.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUIRoot)");
      printf("Error in PyType_Ready(LUIRoot)");
      return;
    }
    Py_INCREF(&Dtool_LUIRoot.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUIRoot, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUIRoot.As_PyTypeObject());
    PyModule_AddObject(module, "LUIRoot", (PyObject *)&Dtool_LUIRoot.As_PyTypeObject());
  }
}


//********************************************************************
//*** Module Object Linker ..
//********************************************************************
static void BuildInstants(PyObject * module) {
  // Module init upcall for LUIAtlas
  Dtool_PyModuleClassInit_LUIAtlas(module);
  // Module init upcall for LUIAtlasDescriptor
  Dtool_PyModuleClassInit_LUIAtlasDescriptor(module);
  // Module init upcall for LUIAtlasPacker
  Dtool_PyModuleClassInit_LUIAtlasPacker(module);
  // Module init upcall for LUIAtlasPool
  Dtool_PyModuleClassInit_LUIAtlasPool(module);
  // Module init upcall for LUIBaseElement
  Dtool_PyModuleClassInit_LUIBaseElement(module);
  // Module init upcall for LUINode
  Dtool_PyModuleClassInit_LUINode(module);
  // Module init upcall for LUISprite
  Dtool_PyModuleClassInit_LUISprite(module);
  // Module init upcall for LUIRoot
  Dtool_PyModuleClassInit_LUIRoot(module);
//********************************************************************
//*** Module Init Upcall ..  Externally Defined Class
//********************************************************************
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

EXPORT_THIS struct LibraryDef LUI_moddef = {python_simple_funcs, BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1409429278,  /* file_identifier */
  "LUI",  /* library_name */
  "jJ0G",  /* library_hash_name */
  "LUI",  /* module_name */
  "InterrogateModule.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  165  /* next_index */
};

Configure(_in_configure_LUI);
ConfigureFn(_in_configure_LUI) {
  interrogate_request_module(&_in_module_def);
}

