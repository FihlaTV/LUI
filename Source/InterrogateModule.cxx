/*
 * This file generated by:
 * F:/P3D/1.9.0-1/built_x64/bin/interrogate -D__inline -DWIN32 -DWIN32_VC -D__int64=long -DCPPPARSER -DP3_INTERROGATE=1 -D__cplusplus -fnames -string -refcount -assert -Dvolatile= -SF:/P3D/1.9.0-1/built_x64/include/parser-inc -SF:/P3D/1.9.0-1/built_x64/include/ -oc Source/InterrogateModule.cxx -od Source/InterrogateModule.in -python-native -module LUI -library LUI -srcdir E:/Projects/Brainz stuff/LUI/Source luiSprite.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_LUI
#include "py_panda.h"
#include "extension.h"

#include "luiSprite.h"
#include "luse.h"
#include "pandabase.h"
#include "pandasymbols.h"
#include "referenceCount.h"
#include "texture.h"

#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif

//********************************************************************
//*** prototypes for .. Global
//********************************************************************
//********************************************************************
//*** prototypes for .. LUISprite
//********************************************************************
typedef LUISprite LUISprite_localtype;
Define_Module_ClassRef(LUI, LUISprite, LUISprite_localtype, LUISprite);

//********************************************************************
//*** prototypes for .. External Objects
//********************************************************************
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LPoint2f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LVector2f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_Texture;

//********************************************************************
//*** Functions for .. Global
//********************************************************************
//********************************************************************
//*** Functions for .. LUISprite
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_pos(LPoint2f const &pos)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_pos_4(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void LUISprite::set_pos(LPoint2f const &pos)
        LPoint2f *arg_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LPoint2f, 1, "LUISprite.set_pos", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_pos(*arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUISprite.set_pos() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_pos(LUISprite this, const LPoint2f pos)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_pos_4_comment =
  "C++ Interface:\n"
  "set_pos(LUISprite this, const LPoint2f pos)\n"
  "\n"
  "// Setter / Getter\n"
  "";
#else
static const char *Dtool_LUISprite_set_pos_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint2f const &LUISprite::get_pos(void) const
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_pos_5(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  // 1-inline LPoint2f const &LUISprite::get_pos(void) const
  LPoint2f const *return_value = &(((const LUISprite*)local_this)->get_pos());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    return (PyObject *)NULL;
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstance((void *)return_value, Dtool_LPoint2f, false, true);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_pos(const LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_pos_5_comment =
  "C++ Interface:\n"
  "get_pos(const LUISprite this)\n"
  "\n"
  "// Setter / Getter\n"
  "";
#else
static const char *Dtool_LUISprite_get_pos_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_size(LVector2f const &size)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_size_6(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void LUISprite::set_size(LVector2f const &size)
        LVector2f *arg_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVector2f, 1, "LUISprite.set_size", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_size(*arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUISprite.set_size() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_size(LUISprite this, const LVector2f size)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_size_6_comment =
  "C++ Interface:\n"
  "set_size(LUISprite this, const LVector2f size)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_size_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f const &LUISprite::get_size(void) const
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_size_7(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  // 1-inline LVector2f const &LUISprite::get_size(void) const
  LVector2f const *return_value = &(((const LUISprite*)local_this)->get_size());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    return (PyObject *)NULL;
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, false, true);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_size(const LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_size_7_comment =
  "C++ Interface:\n"
  "get_size(const LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_size_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_texcoord_start(LVector2f const &texcoord_start)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_texcoord_start_8(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void LUISprite::set_texcoord_start(LVector2f const &texcoord_start)
        LVector2f *arg_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVector2f, 1, "LUISprite.set_texcoord_start", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_texcoord_start(*arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUISprite.set_texcoord_start() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_texcoord_start(LUISprite this, const LVector2f texcoord_start)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_texcoord_start_8_comment =
  "C++ Interface:\n"
  "set_texcoord_start(LUISprite this, const LVector2f texcoord_start)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_texcoord_start_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f const &LUISprite::get_texcoord_start(void) const
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_texcoord_start_9(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  // 1-inline LVector2f const &LUISprite::get_texcoord_start(void) const
  LVector2f const *return_value = &(((const LUISprite*)local_this)->get_texcoord_start());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    return (PyObject *)NULL;
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, false, true);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_texcoord_start(const LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_texcoord_start_9_comment =
  "C++ Interface:\n"
  "get_texcoord_start(const LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_texcoord_start_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_texcoord_end(LVector2f const &texcoord_end)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_texcoord_end_10(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void LUISprite::set_texcoord_end(LVector2f const &texcoord_end)
        LVector2f *arg_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVector2f, 1, "LUISprite.set_texcoord_end", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_texcoord_end(*arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUISprite.set_texcoord_end() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_texcoord_end(LUISprite this, const LVector2f texcoord_end)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_texcoord_end_10_comment =
  "C++ Interface:\n"
  "set_texcoord_end(LUISprite this, const LVector2f texcoord_end)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_texcoord_end_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f const &LUISprite::get_texcoord_end(void) const
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_texcoord_end_11(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  // 1-inline LVector2f const &LUISprite::get_texcoord_end(void) const
  LVector2f const *return_value = &(((const LUISprite*)local_this)->get_texcoord_end());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    return (PyObject *)NULL;
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, false, true);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_texcoord_end(const LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_texcoord_end_11_comment =
  "C++ Interface:\n"
  "get_texcoord_end(const LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_texcoord_end_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_color_12(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void LUISprite::set_color(LVecBase4f const &color)
        LVecBase4f *arg_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LVecBase4f, 1, "LUISprite.set_color", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_color(*arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUISprite.set_color() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_color(LUISprite this, const LVecBase4f color)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_color_12_comment =
  "C++ Interface:\n"
  "set_color(LUISprite this, const LVecBase4f color)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_color_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &LUISprite::get_color(void) const
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_color_13(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  // 1-inline LVecBase4f const &LUISprite::get_color(void) const
  LVecBase4f const *return_value = &(((const LUISprite*)local_this)->get_color());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    return (PyObject *)NULL;
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase4f, false, true);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_color(const LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_color_13_comment =
  "C++ Interface:\n"
  "get_color(const LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_color_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_texture(Texture *tex)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_texture_14(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void LUISprite::set_texture(Texture *tex)
        Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_Texture, 1, "LUISprite.set_texture", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_texture(arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUISprite.set_texture() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_texture(LUISprite this, Texture tex)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_texture_14_comment =
  "C++ Interface:\n"
  "set_texture(LUISprite this, Texture tex)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_texture_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Texture *LUISprite::get_texture(void) const
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_texture_15(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  // 1-inline Texture *LUISprite::get_texture(void) const
  Texture *return_value = ((const LUISprite*)local_this)->get_texture();
  if (return_value != (Texture *)0) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    return (PyObject *)NULL;
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_Texture, true, false, (return_value)->as_typed_object()->get_type_index());
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_texture(const LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_texture_15_comment =
  "C++ Interface:\n"
  "get_texture(const LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_texture_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_z_index(float z_index)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_z_index_16(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_z_index(float z_index)
    if (PyNumber_Check(arg)) {
      (local_this)->set_z_index((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_z_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_z_index(LUISprite this, float z_index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_z_index_16_comment =
  "C++ Interface:\n"
  "set_z_index(LUISprite this, float z_index)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_z_index_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LUISprite::get_z_index(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_z_index_17(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float LUISprite::get_z_index(void)
    float return_value = (local_this)->get_z_index();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyFloat_FromDouble(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_z_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_z_index(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_z_index_17_comment =
  "C++ Interface:\n"
  "get_z_index(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_z_index_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_visible(bool visible)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_visible_18(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_visible(bool visible)
    (local_this)->set_visible((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_visible() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_visible(LUISprite this, bool visible)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_visible_18_comment =
  "C++ Interface:\n"
  "set_visible(LUISprite this, bool visible)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_visible_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool LUISprite::is_visible(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_is_visible_19(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline bool LUISprite::is_visible(void)
    bool return_value = (local_this)->is_visible();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyBool_FromLong(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.is_visible() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "is_visible(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_is_visible_19_comment =
  "C++ Interface:\n"
  "is_visible(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_is_visible_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::hide(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_hide_20(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::hide(void)
    (local_this)->hide();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.hide() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "hide(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_hide_20_comment =
  "C++ Interface:\n"
  "hide(LUISprite this)\n"
  "\n"
  "// Shortcuts for set_visible\n"
  "";
#else
static const char *Dtool_LUISprite_hide_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::show(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_show_21(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::show(void)
    (local_this)->show();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.show() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "show(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_show_21_comment =
  "C++ Interface:\n"
  "show(LUISprite this)\n"
  "\n"
  "// Shortcuts for set_visible\n"
  "";
#else
static const char *Dtool_LUISprite_show_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LUISprite::LUISprite(void)
 *******************************************************************/
int Dtool_Init_LUISprite(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-LUISprite::LUISprite(void)
  LUISprite *return_value = new LUISprite();
  return_value->ref();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    delete return_value;
    return -1;
  }
#endif
  return DTool_PyInit_Finalize(self, return_value, &Dtool_LUISprite, true, false);

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "LUISprite()\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_LUISprite(PyObject *self, PyObject *args) {
  return Dtool_Init_LUISprite(self, args, NULL);
}

inline void *Dtool_UpcastInterface_LUISprite(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUISprite) {
    printf("LUISprite ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUISprite *local_this = (LUISprite *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUISprite) {
    return local_this;
  }
  if (requested_type == &Dtool_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUISprite(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUISprite) {
    return from_this;
  }
  if (from_type == &Dtool_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUISprite*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Py Init Code For .. LUISprite | LUISprite
//********************************************************************
PyMethodDef Dtool_Methods_LUISprite[] = {
  { "set_pos", (PyCFunction) &Dtool_LUISprite_set_pos_4, METH_O, (char *) Dtool_LUISprite_set_pos_4_comment},
  { "setPos", (PyCFunction) &Dtool_LUISprite_set_pos_4, METH_O, (char *) Dtool_LUISprite_set_pos_4_comment},
  { "get_pos", (PyCFunction) &Dtool_LUISprite_get_pos_5, METH_NOARGS, (char *) Dtool_LUISprite_get_pos_5_comment},
  { "getPos", (PyCFunction) &Dtool_LUISprite_get_pos_5, METH_NOARGS, (char *) Dtool_LUISprite_get_pos_5_comment},
  { "set_size", (PyCFunction) &Dtool_LUISprite_set_size_6, METH_O, (char *) Dtool_LUISprite_set_size_6_comment},
  { "setSize", (PyCFunction) &Dtool_LUISprite_set_size_6, METH_O, (char *) Dtool_LUISprite_set_size_6_comment},
  { "get_size", (PyCFunction) &Dtool_LUISprite_get_size_7, METH_NOARGS, (char *) Dtool_LUISprite_get_size_7_comment},
  { "getSize", (PyCFunction) &Dtool_LUISprite_get_size_7, METH_NOARGS, (char *) Dtool_LUISprite_get_size_7_comment},
  { "set_texcoord_start", (PyCFunction) &Dtool_LUISprite_set_texcoord_start_8, METH_O, (char *) Dtool_LUISprite_set_texcoord_start_8_comment},
  { "setTexcoordStart", (PyCFunction) &Dtool_LUISprite_set_texcoord_start_8, METH_O, (char *) Dtool_LUISprite_set_texcoord_start_8_comment},
  { "get_texcoord_start", (PyCFunction) &Dtool_LUISprite_get_texcoord_start_9, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_start_9_comment},
  { "getTexcoordStart", (PyCFunction) &Dtool_LUISprite_get_texcoord_start_9, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_start_9_comment},
  { "set_texcoord_end", (PyCFunction) &Dtool_LUISprite_set_texcoord_end_10, METH_O, (char *) Dtool_LUISprite_set_texcoord_end_10_comment},
  { "setTexcoordEnd", (PyCFunction) &Dtool_LUISprite_set_texcoord_end_10, METH_O, (char *) Dtool_LUISprite_set_texcoord_end_10_comment},
  { "get_texcoord_end", (PyCFunction) &Dtool_LUISprite_get_texcoord_end_11, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_end_11_comment},
  { "getTexcoordEnd", (PyCFunction) &Dtool_LUISprite_get_texcoord_end_11, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_end_11_comment},
  { "set_color", (PyCFunction) &Dtool_LUISprite_set_color_12, METH_O, (char *) Dtool_LUISprite_set_color_12_comment},
  { "setColor", (PyCFunction) &Dtool_LUISprite_set_color_12, METH_O, (char *) Dtool_LUISprite_set_color_12_comment},
  { "get_color", (PyCFunction) &Dtool_LUISprite_get_color_13, METH_NOARGS, (char *) Dtool_LUISprite_get_color_13_comment},
  { "getColor", (PyCFunction) &Dtool_LUISprite_get_color_13, METH_NOARGS, (char *) Dtool_LUISprite_get_color_13_comment},
  { "set_texture", (PyCFunction) &Dtool_LUISprite_set_texture_14, METH_O, (char *) Dtool_LUISprite_set_texture_14_comment},
  { "setTexture", (PyCFunction) &Dtool_LUISprite_set_texture_14, METH_O, (char *) Dtool_LUISprite_set_texture_14_comment},
  { "get_texture", (PyCFunction) &Dtool_LUISprite_get_texture_15, METH_NOARGS, (char *) Dtool_LUISprite_get_texture_15_comment},
  { "getTexture", (PyCFunction) &Dtool_LUISprite_get_texture_15, METH_NOARGS, (char *) Dtool_LUISprite_get_texture_15_comment},
  { "set_z_index", (PyCFunction) &Dtool_LUISprite_set_z_index_16, METH_O, (char *) Dtool_LUISprite_set_z_index_16_comment},
  { "setZIndex", (PyCFunction) &Dtool_LUISprite_set_z_index_16, METH_O, (char *) Dtool_LUISprite_set_z_index_16_comment},
  { "get_z_index", (PyCFunction) &Dtool_LUISprite_get_z_index_17, METH_NOARGS, (char *) Dtool_LUISprite_get_z_index_17_comment},
  { "getZIndex", (PyCFunction) &Dtool_LUISprite_get_z_index_17, METH_NOARGS, (char *) Dtool_LUISprite_get_z_index_17_comment},
  { "set_visible", (PyCFunction) &Dtool_LUISprite_set_visible_18, METH_O, (char *) Dtool_LUISprite_set_visible_18_comment},
  { "setVisible", (PyCFunction) &Dtool_LUISprite_set_visible_18, METH_O, (char *) Dtool_LUISprite_set_visible_18_comment},
  { "is_visible", (PyCFunction) &Dtool_LUISprite_is_visible_19, METH_NOARGS, (char *) Dtool_LUISprite_is_visible_19_comment},
  { "isVisible", (PyCFunction) &Dtool_LUISprite_is_visible_19, METH_NOARGS, (char *) Dtool_LUISprite_is_visible_19_comment},
  { "hide", (PyCFunction) &Dtool_LUISprite_hide_20, METH_NOARGS, (char *) Dtool_LUISprite_hide_20_comment},
  { "show", (PyCFunction) &Dtool_LUISprite_show_21, METH_NOARGS, (char *) Dtool_LUISprite_show_21_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_LUISprite(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ReferenceCount._Dtool_ClassInit(NULL);
    Dtool_LUISprite.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_ReferenceCount.As_PyTypeObject());
    Dtool_LUISprite.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUISprite.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUISprite.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_LUISprite.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUISprite)");
      printf("Error in PyType_Ready(LUISprite)");
      return;
    }
    Py_INCREF(&Dtool_LUISprite.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUISprite, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUISprite.As_PyTypeObject());
    PyModule_AddObject(module, "LUISprite", (PyObject *)&Dtool_LUISprite.As_PyTypeObject());
  }
}


//********************************************************************
//*** Module Object Linker ..
//********************************************************************
static void BuildInstants(PyObject * module) {
  // Module init upcall for LUISprite
  Dtool_PyModuleClassInit_LUISprite(module);
//********************************************************************
//*** Module Init Upcall ..  Externally Defined Class
//********************************************************************
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

EXPORT_THIS struct LibraryDef LUI_moddef = {python_simple_funcs, BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1409085361,  /* file_identifier */
  "LUI",  /* library_name */
  "jJ0G",  /* library_hash_name */
  "LUI",  /* module_name */
  "InterrogateModule.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  58  /* next_index */
};

Configure(_in_configure_LUI);
ConfigureFn(_in_configure_LUI) {
  interrogate_request_module(&_in_module_def);
}

