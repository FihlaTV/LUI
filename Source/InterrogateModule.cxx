/*
 * This file generated by:
 * F:/P3D/1.9.0-1/built_x64/bin/interrogate -D__inline -DWIN32 -DWIN32_VC -D__int64=long -DCPPPARSER -DP3_INTERROGATE=1 -D__cplusplus -fnames -string -refcount -assert -Dvolatile= -SF:/P3D/1.9.0-1/built_x64/include/parser-inc -SF:/P3D/1.9.0-1/built_x64/include/ -oc Source/InterrogateModule.cxx -od Source/InterrogateModule.in -python-native -module LUI -library LUI -srcdir E:/Projects/Brainz stuff/LUI/Source config_lui.h luiAtlas.h luiAtlasPacker.h luiNode.h luiRoot.h luiSprite.h luiVertexPool.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_LUI
#include "py_panda.h"
#include "extension.h"

#include "config_lui.h"
#include "dconfig.h"
#include "filename.h"
#include <fstream>
#include "internalName.h"
#include "luiAtlas.h"
#include "luiAtlasPacker.h"
#include "luiNode.h"
#include "luiRoot.h"
#include "luiSprite.h"
#include "luiVertexPool.h"
#include "luse.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pandasymbols.h"
#include "referenceCount.h"
#include "texture.h"
#include "texturePool.h"
#include "virtualFileSystem.h"

#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif

//********************************************************************
//*** prototypes for .. Global
//********************************************************************
//********************************************************************
//*** prototypes for .. LUIAtlasDescriptor
//********************************************************************
typedef LUIAtlasDescriptor LUIAtlasDescriptor_localtype;
Define_Module_ClassRef(LUI, LUIAtlasDescriptor, LUIAtlasDescriptor_localtype, LUIAtlasDescriptor);

//********************************************************************
//*** prototypes for .. LUIAtlasPacker
//********************************************************************
typedef LUIAtlasPacker LUIAtlasPacker_localtype;
Define_Module_ClassRef(LUI, LUIAtlasPacker, LUIAtlasPacker_localtype, LUIAtlasPacker);

//********************************************************************
//*** prototypes for .. LUINode
//********************************************************************
typedef LUINode LUINode_localtype;
Define_Module_ClassRef(LUI, LUINode, LUINode_localtype, LUINode);

//********************************************************************
//*** prototypes for .. LUISprite
//********************************************************************
typedef LUISprite LUISprite_localtype;
Define_Module_ClassRef(LUI, LUISprite, LUISprite_localtype, LUISprite);

//********************************************************************
//*** prototypes for .. LUIRoot
//********************************************************************
typedef LUIRoot LUIRoot_localtype;
Define_Module_Class(LUI, LUIRoot, LUIRoot_localtype, LUIRoot);

//********************************************************************
//*** prototypes for .. External Objects
//********************************************************************
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LPoint2f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LVector2f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_Texture;

//********************************************************************
//*** Functions for .. Global
//********************************************************************
//********************************************************************
//*** Functions for .. LUIAtlasDescriptor
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LUIAtlasDescriptor::LUIAtlasDescriptor(void)
 *******************************************************************/
int Dtool_Init_LUIAtlasDescriptor(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-LUIAtlasDescriptor::LUIAtlasDescriptor(void)
  LUIAtlasDescriptor *return_value = new LUIAtlasDescriptor();
  return_value->ref();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    delete return_value;
    return -1;
  }
#endif
  return DTool_PyInit_Finalize(self, return_value, &Dtool_LUIAtlasDescriptor, true, false);

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "LUIAtlasDescriptor()\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_LUIAtlasDescriptor(PyObject *self, PyObject *args) {
  return Dtool_Init_LUIAtlasDescriptor(self, args, NULL);
}

inline void *Dtool_UpcastInterface_LUIAtlasDescriptor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUIAtlasDescriptor) {
    printf("LUIAtlasDescriptor ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUIAtlasDescriptor *local_this = (LUIAtlasDescriptor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUIAtlasDescriptor) {
    return local_this;
  }
  if (requested_type == &Dtool_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUIAtlasDescriptor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUIAtlasDescriptor) {
    return from_this;
  }
  if (from_type == &Dtool_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIAtlasDescriptor*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. LUIAtlasPacker
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LVector2f LUIAtlasPacker::find_position(int w, int h)
 *******************************************************************/
static PyObject *Dtool_LUIAtlasPacker_find_position_6(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIAtlasPacker *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIAtlasPacker, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-LVector2f LUIAtlasPacker::find_position(int w, int h)
    int param1;
    int param2;
    static char *keyword_list[] = {(char *)"w", (char *)"h", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:find_position", keyword_list, &param1, &param2)) {
      LVector2f result = (local_this)->find_position((int)param1, (int)param2);
      LVector2f *return_value = new LVector2f(result);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIAtlasPacker.find_position() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "find_position(LUIAtlasPacker this, int w, int h)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlasPacker_find_position_6_comment =
  "C++ Interface:\n"
  "find_position(LUIAtlasPacker this, int w, int h)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIAtlasPacker_find_position_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LUIAtlasPacker::LUIAtlasPacker(int size)
 *******************************************************************/
int Dtool_Init_LUIAtlasPacker(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-LUIAtlasPacker::LUIAtlasPacker(int size)
  int param0;
  static char *keyword_list[] = {(char *)"size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i:LUIAtlasPacker", keyword_list, &param0)) {
    LUIAtlasPacker *return_value = new LUIAtlasPacker((int)param0);
    return_value->ref();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      delete return_value;
      return -1;
    }
#endif
    return DTool_PyInit_Finalize(self, return_value, &Dtool_LUIAtlasPacker, true, false);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "LUIAtlasPacker(int size)\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_LUIAtlasPacker(PyObject *self, PyObject *args) {
  return Dtool_Init_LUIAtlasPacker(self, args, NULL);
}

inline void *Dtool_UpcastInterface_LUIAtlasPacker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUIAtlasPacker) {
    printf("LUIAtlasPacker ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUIAtlasPacker *local_this = (LUIAtlasPacker *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUIAtlasPacker) {
    return local_this;
  }
  if (requested_type == &Dtool_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUIAtlasPacker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUIAtlasPacker) {
    return from_this;
  }
  if (from_type == &Dtool_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIAtlasPacker*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. LUINode
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LUIAtlasDescriptor LUINode::get_atlas_image(basic_string< char > identifier)
 *******************************************************************/
static PyObject *Dtool_LUINode_get_atlas_image_9(PyObject *self, PyObject *arg) {
  LUINode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUINode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-LUIAtlasDescriptor LUINode::get_atlas_image(basic_string< char > identifier)
    char *param1_str;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      LUIAtlasDescriptor result = (local_this)->get_atlas_image(basic_string<char>(param1_str, param1_len));
      LUIAtlasDescriptor *return_value = new LUIAtlasDescriptor(result);
      if (return_value != (LUIAtlasDescriptor *)0) {
        return_value->ref();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstance((void *)return_value, Dtool_LUIAtlasDescriptor, true, false);
      }
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUINode.get_atlas_image() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_atlas_image(LUINode this, str identifier)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUINode_get_atlas_image_9_comment =
  "C++ Interface:\n"
  "get_atlas_image(LUINode this, str identifier)\n"
  "\n"
  "";
#else
static const char *Dtool_LUINode_get_atlas_image_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< LUISprite > LUINode::attach_sprite(float x, float y, LUIAtlasDescriptor desc)
 *******************************************************************/
static PyObject *Dtool_LUINode_attach_sprite_10(PyObject *self, PyObject *args, PyObject *kwds) {
  LUINode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUINode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-PointerTo< LUISprite > LUINode::attach_sprite(float x, float y, LUIAtlasDescriptor desc)
        float param1;
        float param2;
        PyObject *param3;
        static char *keyword_list[] = {(char *)"x", (char *)"y", (char *)"desc", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:attach_sprite", keyword_list, &param1, &param2, &param3)) {
          LUIAtlasDescriptor *param3_this = (LUIAtlasDescriptor *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LUIAtlasDescriptor, 3, "LUINode.attach_sprite", 1, coerced_ptr, report_errors);

          if (param3_this != NULL) {
            PointerTo< LUISprite > return_value = (local_this)->attach_sprite((float)param1, (float)param2, *param3_this);
            if (return_value != (LUISprite *)0) {
              return_value->ref();
            }
            Py_XDECREF(coerced);
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            if (return_value.p() == NULL) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstance((void *)return_value.p(), Dtool_LUISprite, true, false);
            }
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUINode.attach_sprite() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "attach_sprite(LUINode this, float x, float y, const LUIAtlasDescriptor desc)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUINode_attach_sprite_10_comment =
  "C++ Interface:\n"
  "attach_sprite(LUINode this, float x, float y, const LUIAtlasDescriptor desc)\n"
  "\n"
  "";
#else
static const char *Dtool_LUINode_attach_sprite_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LUINode::operator +=(PointerTo< LUINode > node)
 *******************************************************************/
static PyObject *Dtool_LUINode_operator_11(PyObject *self, PyObject *arg) {
  LUINode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUINode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-void LUINode::operator +=(PointerTo< LUINode > node)
        LUINode *arg_this = (LUINode *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LUINode, 1, "LUINode.__iadd__", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->operator +=(arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(self);
          return self;
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUINode.__iadd__() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "__iadd__(LUINode this, const LUINode node)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUINode_operator_11_comment =
  "C++ Interface:\n"
  "__iadd__(LUINode this, const LUINode node)\n"
  "\n"
  "";
#else
static const char *Dtool_LUINode_operator_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LUINode::LUINode(void)
 *******************************************************************/
int Dtool_Init_LUINode(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-LUINode::LUINode(void)
  LUINode *return_value = new LUINode();
  return_value->ref();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    delete return_value;
    return -1;
  }
#endif
  return DTool_PyInit_Finalize(self, return_value, &Dtool_LUINode, true, false);

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "LUINode()\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_LUINode(PyObject *self, PyObject *args) {
  return Dtool_Init_LUINode(self, args, NULL);
}

inline void *Dtool_UpcastInterface_LUINode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUINode) {
    printf("LUINode ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUINode *local_this = (LUINode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUINode) {
    return local_this;
  }
  if (requested_type == &Dtool_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUINode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUINode) {
    return from_this;
  }
  if (from_type == &Dtool_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUINode*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. LUISprite
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_pos(LPoint2f const &pos)
 * inline void LUISprite::set_pos(float x, float y)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_pos_14(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUISprite::set_pos(LPoint2f const &pos)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"pos", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_pos", keyword_list, &param1)) {
            LPoint2f *param1_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2f, 1, "LUISprite.set_pos", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_pos(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUISprite.set_pos() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 2: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUISprite::set_pos(float x, float y)
      float param1;
      float param2;
      static char *keyword_list[] = {(char *)"x", (char *)"y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_pos", keyword_list, &param1, &param2)) {
        (local_this)->set_pos((float)param1, (float)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUISprite.set_pos() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_pos() takes 2 or 3 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_pos(LUISprite this, const LPoint2f pos)\n"
      "set_pos(LUISprite this, float x, float y)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_pos_14_comment =
  "C++ Interface:\n"
  "set_pos(LUISprite this, const LPoint2f pos)\n"
  "set_pos(LUISprite this, float x, float y)\n"
  "\n"
  "// Setter / Getter \n"
  "// Position\n"
  "\n"
  "// Setter / Getter \n"
  "// Position\n"
  "";
#else
static const char *Dtool_LUISprite_set_pos_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_x(float x)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_x_15(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_x(float x)
    if (PyNumber_Check(arg)) {
      (local_this)->set_x((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_x() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_x(LUISprite this, float x)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_x_15_comment =
  "C++ Interface:\n"
  "set_x(LUISprite this, float x)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_x_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_y(float y)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_y_16(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_y(float y)
    if (PyNumber_Check(arg)) {
      (local_this)->set_y((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_y() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_y(LUISprite this, float y)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_y_16_comment =
  "C++ Interface:\n"
  "set_y(LUISprite this, float y)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_y_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LUISprite::get_x(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_x_17(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float LUISprite::get_x(void)
    float return_value = (local_this)->get_x();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyFloat_FromDouble(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_x() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_x(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_x_17_comment =
  "C++ Interface:\n"
  "get_x(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_x_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LUISprite::get_y(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_y_18(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float LUISprite::get_y(void)
    float return_value = (local_this)->get_y();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyFloat_FromDouble(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_y() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_y(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_y_18_comment =
  "C++ Interface:\n"
  "get_y(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_y_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint2f LUISprite::get_pos(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_pos_19(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LPoint2f LUISprite::get_pos(void)
    LPoint2f result = (local_this)->get_pos();
    LPoint2f *return_value = new LPoint2f(result);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_LPoint2f, true, false);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_pos() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_pos(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_pos_19_comment =
  "C++ Interface:\n"
  "get_pos(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_pos_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_size(LVector2f const &size)
 * inline void LUISprite::set_size(float w, float h)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_size_20(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUISprite::set_size(LVector2f const &size)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"size", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_size", keyword_list, &param1)) {
            LVector2f *param1_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector2f, 1, "LUISprite.set_size", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_size(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUISprite.set_size() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 2: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUISprite::set_size(float w, float h)
      float param1;
      float param2;
      static char *keyword_list[] = {(char *)"w", (char *)"h", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_size", keyword_list, &param1, &param2)) {
        (local_this)->set_size((float)param1, (float)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUISprite.set_size() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_size() takes 2 or 3 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_size(LUISprite this, const LVector2f size)\n"
      "set_size(LUISprite this, float w, float h)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_size_20_comment =
  "C++ Interface:\n"
  "set_size(LUISprite this, const LVector2f size)\n"
  "set_size(LUISprite this, float w, float h)\n"
  "\n"
  "// Size\n"
  "\n"
  "// Size\n"
  "";
#else
static const char *Dtool_LUISprite_set_size_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_width(float w)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_width_21(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_width(float w)
    if (PyNumber_Check(arg)) {
      (local_this)->set_width((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_width() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_width(LUISprite this, float w)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_width_21_comment =
  "C++ Interface:\n"
  "set_width(LUISprite this, float w)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_width_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_height(float h)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_height_22(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_height(float h)
    if (PyNumber_Check(arg)) {
      (local_this)->set_height((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_height() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_height(LUISprite this, float h)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_height_22_comment =
  "C++ Interface:\n"
  "set_height(LUISprite this, float h)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_height_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LUISprite::get_width(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_width_23(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float LUISprite::get_width(void)
    float return_value = (local_this)->get_width();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyFloat_FromDouble(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_width() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_width(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_width_23_comment =
  "C++ Interface:\n"
  "get_width(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_width_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LUISprite::get_height(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_height_24(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float LUISprite::get_height(void)
    float return_value = (local_this)->get_height();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyFloat_FromDouble(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_height() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_height(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_height_24_comment =
  "C++ Interface:\n"
  "get_height(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_height_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f const &LUISprite::get_size(void) const
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_size_25(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  // 1-inline LVector2f const &LUISprite::get_size(void) const
  LVector2f const *return_value = &(((const LUISprite*)local_this)->get_size());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    return (PyObject *)NULL;
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, false, true);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_size(const LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_size_25_comment =
  "C++ Interface:\n"
  "get_size(const LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_size_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_texcoord_start(LVector2f const &texcoord_start)
 * inline void LUISprite::set_texcoord_start(float u, float v)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_texcoord_start_26(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUISprite::set_texcoord_start(LVector2f const &texcoord_start)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"texcoord_start", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_texcoord_start", keyword_list, &param1)) {
            LVector2f *param1_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector2f, 1, "LUISprite.set_texcoord_start", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_texcoord_start(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUISprite.set_texcoord_start() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 2: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUISprite::set_texcoord_start(float u, float v)
      float param1;
      float param2;
      static char *keyword_list[] = {(char *)"u", (char *)"v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_texcoord_start", keyword_list, &param1, &param2)) {
        (local_this)->set_texcoord_start((float)param1, (float)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUISprite.set_texcoord_start() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_texcoord_start() takes 2 or 3 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_texcoord_start(LUISprite this, const LVector2f texcoord_start)\n"
      "set_texcoord_start(LUISprite this, float u, float v)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_texcoord_start_26_comment =
  "C++ Interface:\n"
  "set_texcoord_start(LUISprite this, const LVector2f texcoord_start)\n"
  "set_texcoord_start(LUISprite this, float u, float v)\n"
  "\n"
  "// Texcoord\n"
  "\n"
  "// Texcoord\n"
  "";
#else
static const char *Dtool_LUISprite_set_texcoord_start_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f LUISprite::get_texcoord_start(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_texcoord_start_27(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVector2f LUISprite::get_texcoord_start(void)
    LVector2f result = (local_this)->get_texcoord_start();
    LVector2f *return_value = new LVector2f(result);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, true, false);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_texcoord_start() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_texcoord_start(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_texcoord_start_27_comment =
  "C++ Interface:\n"
  "get_texcoord_start(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_texcoord_start_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_texcoord_end(LVector2f const &texcoord_end)
 * inline void LUISprite::set_texcoord_end(float u, float v)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_texcoord_end_28(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUISprite::set_texcoord_end(LVector2f const &texcoord_end)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"texcoord_end", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_texcoord_end", keyword_list, &param1)) {
            LVector2f *param1_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector2f, 1, "LUISprite.set_texcoord_end", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_texcoord_end(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUISprite.set_texcoord_end() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 2: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUISprite::set_texcoord_end(float u, float v)
      float param1;
      float param2;
      static char *keyword_list[] = {(char *)"u", (char *)"v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_texcoord_end", keyword_list, &param1, &param2)) {
        (local_this)->set_texcoord_end((float)param1, (float)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUISprite.set_texcoord_end() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_texcoord_end() takes 2 or 3 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_texcoord_end(LUISprite this, const LVector2f texcoord_end)\n"
      "set_texcoord_end(LUISprite this, float u, float v)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_texcoord_end_28_comment =
  "C++ Interface:\n"
  "set_texcoord_end(LUISprite this, const LVector2f texcoord_end)\n"
  "set_texcoord_end(LUISprite this, float u, float v)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_texcoord_end_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f LUISprite::get_texcoord_end(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_texcoord_end_29(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVector2f LUISprite::get_texcoord_end(void)
    LVector2f result = (local_this)->get_texcoord_end();
    LVector2f *return_value = new LVector2f(result);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, true, false);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_texcoord_end() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_texcoord_end(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_texcoord_end_29_comment =
  "C++ Interface:\n"
  "get_texcoord_end(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_texcoord_end_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_color(LVecBase4f const &color)
 * inline void LUISprite::set_color(float r, float g, float b, float a)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_color_30(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUISprite::set_color(LVecBase4f const &color)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"color", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_color", keyword_list, &param1)) {
            LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "LUISprite.set_color", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_color(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUISprite.set_color() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 4: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUISprite::set_color(float r, float g, float b, float a)
      float param1;
      float param2;
      float param3;
      float param4;
      static char *keyword_list[] = {(char *)"r", (char *)"g", (char *)"b", (char *)"a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_color", keyword_list, &param1, &param2, &param3, &param4)) {
        (local_this)->set_color((float)param1, (float)param2, (float)param3, (float)param4);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUISprite.set_color() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_color() takes 2 or 5 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_color(LUISprite this, const LVecBase4f color)\n"
      "set_color(LUISprite this, float r, float g, float b, float a)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_color_30_comment =
  "C++ Interface:\n"
  "set_color(LUISprite this, const LVecBase4f color)\n"
  "set_color(LUISprite this, float r, float g, float b, float a)\n"
  "\n"
  "// Color\n"
  "\n"
  "// Color\n"
  "";
#else
static const char *Dtool_LUISprite_set_color_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f LUISprite::get_color(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_color_31(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase4f LUISprite::get_color(void)
    LVecBase4f result = (local_this)->get_color();
    LVecBase4f *return_value = new LVecBase4f(result);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase4f, true, false);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_color() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_color(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_color_31_comment =
  "C++ Interface:\n"
  "get_color(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_color_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_texture(Texture *tex)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_texture_32(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void LUISprite::set_texture(Texture *tex)
        Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_Texture, 1, "LUISprite.set_texture", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_texture(arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUISprite.set_texture() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_texture(LUISprite this, Texture tex)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_texture_32_comment =
  "C++ Interface:\n"
  "set_texture(LUISprite this, Texture tex)\n"
  "\n"
  "// Texture\n"
  "";
#else
static const char *Dtool_LUISprite_set_texture_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Texture *LUISprite::get_texture(void) const
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_texture_33(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  // 1-inline Texture *LUISprite::get_texture(void) const
  Texture *return_value = ((const LUISprite*)local_this)->get_texture();
  if (return_value != (Texture *)0) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    return (PyObject *)NULL;
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_Texture, true, false, (return_value)->as_typed_object()->get_type_index());
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_texture(const LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_texture_33_comment =
  "C++ Interface:\n"
  "get_texture(const LUISprite this)\n"
  "\n"
  "// Texture\n"
  "";
#else
static const char *Dtool_LUISprite_get_texture_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_z_index(float z_index)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_z_index_34(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_z_index(float z_index)
    if (PyNumber_Check(arg)) {
      (local_this)->set_z_index((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_z_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_z_index(LUISprite this, float z_index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_z_index_34_comment =
  "C++ Interface:\n"
  "set_z_index(LUISprite this, float z_index)\n"
  "\n"
  "// Z-Index\n"
  "";
#else
static const char *Dtool_LUISprite_set_z_index_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LUISprite::get_z_index(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_z_index_35(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float LUISprite::get_z_index(void)
    float return_value = (local_this)->get_z_index();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyFloat_FromDouble(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_z_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_z_index(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_z_index_35_comment =
  "C++ Interface:\n"
  "get_z_index(LUISprite this)\n"
  "\n"
  "// Z-Index\n"
  "";
#else
static const char *Dtool_LUISprite_get_z_index_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_visible(bool visible)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_visible_36(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_visible(bool visible)
    (local_this)->set_visible((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_visible() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_visible(LUISprite this, bool visible)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_visible_36_comment =
  "C++ Interface:\n"
  "set_visible(LUISprite this, bool visible)\n"
  "\n"
  "// Visible\n"
  "";
#else
static const char *Dtool_LUISprite_set_visible_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool LUISprite::is_visible(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_is_visible_37(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline bool LUISprite::is_visible(void)
    bool return_value = (local_this)->is_visible();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyBool_FromLong(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.is_visible() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "is_visible(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_is_visible_37_comment =
  "C++ Interface:\n"
  "is_visible(LUISprite this)\n"
  "\n"
  "// Visible\n"
  "";
#else
static const char *Dtool_LUISprite_is_visible_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::hide(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_hide_38(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::hide(void)
    (local_this)->hide();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.hide() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "hide(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_hide_38_comment =
  "C++ Interface:\n"
  "hide(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_hide_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::show(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_show_39(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::show(void)
    (local_this)->show();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.show() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "show(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_show_39_comment =
  "C++ Interface:\n"
  "show(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_show_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LUISprite::LUISprite(void)
 *******************************************************************/
int Dtool_Init_LUISprite(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-LUISprite::LUISprite(void)
  LUISprite *return_value = new LUISprite();
  return_value->ref();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    delete return_value;
    return -1;
  }
#endif
  return DTool_PyInit_Finalize(self, return_value, &Dtool_LUISprite, true, false);

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "LUISprite()\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_LUISprite(PyObject *self, PyObject *args) {
  return Dtool_Init_LUISprite(self, args, NULL);
}

inline void *Dtool_UpcastInterface_LUISprite(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUISprite) {
    printf("LUISprite ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUISprite *local_this = (LUISprite *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUISprite) {
    return local_this;
  }
  if (requested_type == &Dtool_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUISprite(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUISprite) {
    return from_this;
  }
  if (from_type == &Dtool_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUISprite*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. LUIRoot
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * PointerTo< LUISprite > LUIRoot::attach_sprite(float x, float y, LUIAtlasDescriptor desc)
 *******************************************************************/
static PyObject *Dtool_LUIRoot_attach_sprite_43(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIRoot *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIRoot, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-PointerTo< LUISprite > LUIRoot::attach_sprite(float x, float y, LUIAtlasDescriptor desc)
        float param1;
        float param2;
        PyObject *param3;
        static char *keyword_list[] = {(char *)"x", (char *)"y", (char *)"desc", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "ffO:attach_sprite", keyword_list, &param1, &param2, &param3)) {
          LUIAtlasDescriptor *param3_this = (LUIAtlasDescriptor *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LUIAtlasDescriptor, 3, "LUIRoot.attach_sprite", 1, coerced_ptr, report_errors);

          if (param3_this != NULL) {
            PointerTo< LUISprite > return_value = (local_this)->attach_sprite((float)param1, (float)param2, *param3_this);
            if (return_value != (LUISprite *)0) {
              return_value->ref();
            }
            Py_XDECREF(coerced);
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
              notify->clear_assert_failed();
              return (PyObject *)NULL;
            }
#endif
            if (return_value.p() == NULL) {
              Py_INCREF(Py_None);
              return Py_None;
            } else {
              return DTool_CreatePyInstance((void *)return_value.p(), Dtool_LUISprite, true, false);
            }
          }
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUIRoot.attach_sprite() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "attach_sprite(LUIRoot this, float x, float y, const LUIAtlasDescriptor desc)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIRoot_attach_sprite_43_comment =
  "C++ Interface:\n"
  "attach_sprite(LUIRoot this, float x, float y, const LUIAtlasDescriptor desc)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIRoot_attach_sprite_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LUIRoot::operator +=(PointerTo< LUINode > node)
 *******************************************************************/
static PyObject *Dtool_LUIRoot_operator_44(PyObject *self, PyObject *arg) {
  LUIRoot *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIRoot, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-void LUIRoot::operator +=(PointerTo< LUINode > node)
        LUINode *arg_this = (LUINode *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LUINode, 1, "LUIRoot.__iadd__", 1, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->operator +=(arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(self);
          return self;
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUIRoot.__iadd__() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "__iadd__(LUIRoot this, const LUINode node)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIRoot_operator_44_comment =
  "C++ Interface:\n"
  "__iadd__(LUIRoot this, const LUINode node)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIRoot_operator_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void LUIRoot::load_atlas(basic_string< char > const &atlas_id, basic_string< char > const &atlas_desc_path, basic_string< char > const &atlas_tex_path)
 *******************************************************************/
static PyObject *Dtool_LUIRoot_load_atlas_45(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIRoot *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUIRoot, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-void LUIRoot::load_atlas(basic_string< char > const &atlas_id, basic_string< char > const &atlas_desc_path, basic_string< char > const &atlas_tex_path)
    char *param1_str;
    Py_ssize_t param1_len;
    char *param2_str;
    Py_ssize_t param2_len;
    char *param3_str;
    Py_ssize_t param3_len;
    static char *keyword_list[] = {(char *)"atlas_id", (char *)"atlas_desc_path", (char *)"atlas_tex_path", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#:load_atlas", keyword_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3_str, &param3_len)) {
      (local_this)->load_atlas(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUIRoot.load_atlas() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "load_atlas(LUIRoot this, str atlas_id, str atlas_desc_path, str atlas_tex_path)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUIRoot_load_atlas_45_comment =
  "C++ Interface:\n"
  "load_atlas(LUIRoot this, str atlas_id, str atlas_desc_path, str atlas_tex_path)\n"
  "\n"
  "";
#else
static const char *Dtool_LUIRoot_load_atlas_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LUIRoot::LUIRoot(void)
 *******************************************************************/
int Dtool_Init_LUIRoot(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-LUIRoot::LUIRoot(void)
  LUIRoot *return_value = new LUIRoot();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    delete return_value;
    return -1;
  }
#endif
  return DTool_PyInit_Finalize(self, return_value, &Dtool_LUIRoot, true, false);

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "LUIRoot()\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_LUIRoot(PyObject *self, PyObject *args) {
  return Dtool_Init_LUIRoot(self, args, NULL);
}

inline void *Dtool_UpcastInterface_LUIRoot(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUIRoot) {
    printf("LUIRoot ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUIRoot *local_this = (LUIRoot *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUIRoot) {
    return local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUIRoot(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUIRoot) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Py Init Code For .. LUIAtlasDescriptor | LUIAtlasDescriptor
//********************************************************************
PyMethodDef Dtool_Methods_LUIAtlasDescriptor[] = {
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_LUIAtlasDescriptor(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ReferenceCount._Dtool_ClassInit(NULL);
    Dtool_LUIAtlasDescriptor.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_ReferenceCount.As_PyTypeObject());
    Dtool_LUIAtlasDescriptor.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUIAtlasDescriptor.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUIAtlasDescriptor.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_LUIAtlasDescriptor.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUIAtlasDescriptor)");
      printf("Error in PyType_Ready(LUIAtlasDescriptor)");
      return;
    }
    Py_INCREF(&Dtool_LUIAtlasDescriptor.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUIAtlasDescriptor, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUIAtlasDescriptor.As_PyTypeObject());
    PyModule_AddObject(module, "LUIAtlasDescriptor", (PyObject *)&Dtool_LUIAtlasDescriptor.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. LUIAtlasPacker | LUIAtlasPacker
//********************************************************************
PyMethodDef Dtool_Methods_LUIAtlasPacker[] = {
  { "find_position", (PyCFunction) &Dtool_LUIAtlasPacker_find_position_6, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIAtlasPacker_find_position_6_comment},
  { "findPosition", (PyCFunction) &Dtool_LUIAtlasPacker_find_position_6, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIAtlasPacker_find_position_6_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_LUIAtlasPacker(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ReferenceCount._Dtool_ClassInit(NULL);
    Dtool_LUIAtlasPacker.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_ReferenceCount.As_PyTypeObject());
    Dtool_LUIAtlasPacker.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUIAtlasPacker.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUIAtlasPacker.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_LUIAtlasPacker.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUIAtlasPacker)");
      printf("Error in PyType_Ready(LUIAtlasPacker)");
      return;
    }
    Py_INCREF(&Dtool_LUIAtlasPacker.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUIAtlasPacker, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUIAtlasPacker.As_PyTypeObject());
    PyModule_AddObject(module, "LUIAtlasPacker", (PyObject *)&Dtool_LUIAtlasPacker.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. LUINode | LUINode
//********************************************************************
PyMethodDef Dtool_Methods_LUINode[] = {
  { "get_atlas_image", (PyCFunction) &Dtool_LUINode_get_atlas_image_9, METH_O, (char *) Dtool_LUINode_get_atlas_image_9_comment},
  { "getAtlasImage", (PyCFunction) &Dtool_LUINode_get_atlas_image_9, METH_O, (char *) Dtool_LUINode_get_atlas_image_9_comment},
  { "attach_sprite", (PyCFunction) &Dtool_LUINode_attach_sprite_10, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUINode_attach_sprite_10_comment},
  { "attachSprite", (PyCFunction) &Dtool_LUINode_attach_sprite_10, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUINode_attach_sprite_10_comment},
  { "__iadd__", (PyCFunction) &Dtool_LUINode_operator_11, METH_O, (char *) Dtool_LUINode_operator_11_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions.
//     LUINode ...tp_as_number->nb_inplace_add = __iadd__
//////////////////
static PyObject *Dtool_LUINode_operator_11__iadd__(PyObject *self, PyObject *arg) {
  return Dtool_LUINode_operator_11(self, arg);
}

void Dtool_PyModuleClassInit_LUINode(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ReferenceCount._Dtool_ClassInit(NULL);
    Dtool_LUINode.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_ReferenceCount.As_PyTypeObject());
    Dtool_LUINode.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUINode.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUINode.As_PyTypeObject().tp_dict);
#if PY_VERSION_HEX >= 0x2000000
    // tp_as_number->nb_inplace_add = __iadd__
    Dtool_LUINode.As_PyTypeObject().tp_as_number->nb_inplace_add = &Dtool_LUINode_operator_11__iadd__;
#endif
    if (PyType_Ready(&Dtool_LUINode.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUINode)");
      printf("Error in PyType_Ready(LUINode)");
      return;
    }
    Py_INCREF(&Dtool_LUINode.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUINode, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUINode.As_PyTypeObject());
    PyModule_AddObject(module, "LUINode", (PyObject *)&Dtool_LUINode.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. LUISprite | LUISprite
//********************************************************************
PyMethodDef Dtool_Methods_LUISprite[] = {
  { "set_pos", (PyCFunction) &Dtool_LUISprite_set_pos_14, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_pos_14_comment},
  { "setPos", (PyCFunction) &Dtool_LUISprite_set_pos_14, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_pos_14_comment},
  { "set_x", (PyCFunction) &Dtool_LUISprite_set_x_15, METH_O, (char *) Dtool_LUISprite_set_x_15_comment},
  { "setX", (PyCFunction) &Dtool_LUISprite_set_x_15, METH_O, (char *) Dtool_LUISprite_set_x_15_comment},
  { "set_y", (PyCFunction) &Dtool_LUISprite_set_y_16, METH_O, (char *) Dtool_LUISprite_set_y_16_comment},
  { "setY", (PyCFunction) &Dtool_LUISprite_set_y_16, METH_O, (char *) Dtool_LUISprite_set_y_16_comment},
  { "get_x", (PyCFunction) &Dtool_LUISprite_get_x_17, METH_NOARGS, (char *) Dtool_LUISprite_get_x_17_comment},
  { "getX", (PyCFunction) &Dtool_LUISprite_get_x_17, METH_NOARGS, (char *) Dtool_LUISprite_get_x_17_comment},
  { "get_y", (PyCFunction) &Dtool_LUISprite_get_y_18, METH_NOARGS, (char *) Dtool_LUISprite_get_y_18_comment},
  { "getY", (PyCFunction) &Dtool_LUISprite_get_y_18, METH_NOARGS, (char *) Dtool_LUISprite_get_y_18_comment},
  { "get_pos", (PyCFunction) &Dtool_LUISprite_get_pos_19, METH_NOARGS, (char *) Dtool_LUISprite_get_pos_19_comment},
  { "getPos", (PyCFunction) &Dtool_LUISprite_get_pos_19, METH_NOARGS, (char *) Dtool_LUISprite_get_pos_19_comment},
  { "set_size", (PyCFunction) &Dtool_LUISprite_set_size_20, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_size_20_comment},
  { "setSize", (PyCFunction) &Dtool_LUISprite_set_size_20, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_size_20_comment},
  { "set_width", (PyCFunction) &Dtool_LUISprite_set_width_21, METH_O, (char *) Dtool_LUISprite_set_width_21_comment},
  { "setWidth", (PyCFunction) &Dtool_LUISprite_set_width_21, METH_O, (char *) Dtool_LUISprite_set_width_21_comment},
  { "set_height", (PyCFunction) &Dtool_LUISprite_set_height_22, METH_O, (char *) Dtool_LUISprite_set_height_22_comment},
  { "setHeight", (PyCFunction) &Dtool_LUISprite_set_height_22, METH_O, (char *) Dtool_LUISprite_set_height_22_comment},
  { "get_width", (PyCFunction) &Dtool_LUISprite_get_width_23, METH_NOARGS, (char *) Dtool_LUISprite_get_width_23_comment},
  { "getWidth", (PyCFunction) &Dtool_LUISprite_get_width_23, METH_NOARGS, (char *) Dtool_LUISprite_get_width_23_comment},
  { "get_height", (PyCFunction) &Dtool_LUISprite_get_height_24, METH_NOARGS, (char *) Dtool_LUISprite_get_height_24_comment},
  { "getHeight", (PyCFunction) &Dtool_LUISprite_get_height_24, METH_NOARGS, (char *) Dtool_LUISprite_get_height_24_comment},
  { "get_size", (PyCFunction) &Dtool_LUISprite_get_size_25, METH_NOARGS, (char *) Dtool_LUISprite_get_size_25_comment},
  { "getSize", (PyCFunction) &Dtool_LUISprite_get_size_25, METH_NOARGS, (char *) Dtool_LUISprite_get_size_25_comment},
  { "set_texcoord_start", (PyCFunction) &Dtool_LUISprite_set_texcoord_start_26, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_texcoord_start_26_comment},
  { "setTexcoordStart", (PyCFunction) &Dtool_LUISprite_set_texcoord_start_26, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_texcoord_start_26_comment},
  { "get_texcoord_start", (PyCFunction) &Dtool_LUISprite_get_texcoord_start_27, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_start_27_comment},
  { "getTexcoordStart", (PyCFunction) &Dtool_LUISprite_get_texcoord_start_27, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_start_27_comment},
  { "set_texcoord_end", (PyCFunction) &Dtool_LUISprite_set_texcoord_end_28, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_texcoord_end_28_comment},
  { "setTexcoordEnd", (PyCFunction) &Dtool_LUISprite_set_texcoord_end_28, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_texcoord_end_28_comment},
  { "get_texcoord_end", (PyCFunction) &Dtool_LUISprite_get_texcoord_end_29, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_end_29_comment},
  { "getTexcoordEnd", (PyCFunction) &Dtool_LUISprite_get_texcoord_end_29, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_end_29_comment},
  { "set_color", (PyCFunction) &Dtool_LUISprite_set_color_30, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_color_30_comment},
  { "setColor", (PyCFunction) &Dtool_LUISprite_set_color_30, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_color_30_comment},
  { "get_color", (PyCFunction) &Dtool_LUISprite_get_color_31, METH_NOARGS, (char *) Dtool_LUISprite_get_color_31_comment},
  { "getColor", (PyCFunction) &Dtool_LUISprite_get_color_31, METH_NOARGS, (char *) Dtool_LUISprite_get_color_31_comment},
  { "set_texture", (PyCFunction) &Dtool_LUISprite_set_texture_32, METH_O, (char *) Dtool_LUISprite_set_texture_32_comment},
  { "setTexture", (PyCFunction) &Dtool_LUISprite_set_texture_32, METH_O, (char *) Dtool_LUISprite_set_texture_32_comment},
  { "get_texture", (PyCFunction) &Dtool_LUISprite_get_texture_33, METH_NOARGS, (char *) Dtool_LUISprite_get_texture_33_comment},
  { "getTexture", (PyCFunction) &Dtool_LUISprite_get_texture_33, METH_NOARGS, (char *) Dtool_LUISprite_get_texture_33_comment},
  { "set_z_index", (PyCFunction) &Dtool_LUISprite_set_z_index_34, METH_O, (char *) Dtool_LUISprite_set_z_index_34_comment},
  { "setZIndex", (PyCFunction) &Dtool_LUISprite_set_z_index_34, METH_O, (char *) Dtool_LUISprite_set_z_index_34_comment},
  { "get_z_index", (PyCFunction) &Dtool_LUISprite_get_z_index_35, METH_NOARGS, (char *) Dtool_LUISprite_get_z_index_35_comment},
  { "getZIndex", (PyCFunction) &Dtool_LUISprite_get_z_index_35, METH_NOARGS, (char *) Dtool_LUISprite_get_z_index_35_comment},
  { "set_visible", (PyCFunction) &Dtool_LUISprite_set_visible_36, METH_O, (char *) Dtool_LUISprite_set_visible_36_comment},
  { "setVisible", (PyCFunction) &Dtool_LUISprite_set_visible_36, METH_O, (char *) Dtool_LUISprite_set_visible_36_comment},
  { "is_visible", (PyCFunction) &Dtool_LUISprite_is_visible_37, METH_NOARGS, (char *) Dtool_LUISprite_is_visible_37_comment},
  { "isVisible", (PyCFunction) &Dtool_LUISprite_is_visible_37, METH_NOARGS, (char *) Dtool_LUISprite_is_visible_37_comment},
  { "hide", (PyCFunction) &Dtool_LUISprite_hide_38, METH_NOARGS, (char *) Dtool_LUISprite_hide_38_comment},
  { "show", (PyCFunction) &Dtool_LUISprite_show_39, METH_NOARGS, (char *) Dtool_LUISprite_show_39_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_LUISprite(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
#ifndef NDEBUG
    // Class documentation string
    Dtool_LUISprite.As_PyTypeObject().tp_doc =
      "////////////////////////////////////////////////////////////////////\n"
      "//       Class : LUISprite\n"
      "// Description : A LUISprite stores a single card, including position,\n"
      "//               scale, and uv coordinates. It also notifies the\n"
      "//               LUIVertexPool when any scalar or texture got changed.\n"
      "////////////////////////////////////////////////////////////////////";
#endif
    // Dependent objects
    Dtool_ReferenceCount._Dtool_ClassInit(NULL);
    Dtool_LUISprite.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_ReferenceCount.As_PyTypeObject());
    Dtool_LUISprite.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUISprite.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUISprite.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_LUISprite.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUISprite)");
      printf("Error in PyType_Ready(LUISprite)");
      return;
    }
    Py_INCREF(&Dtool_LUISprite.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUISprite, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUISprite.As_PyTypeObject());
    PyModule_AddObject(module, "LUISprite", (PyObject *)&Dtool_LUISprite.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. LUIRoot | LUIRoot
//********************************************************************
PyMethodDef Dtool_Methods_LUIRoot[] = {
  { "attach_sprite", (PyCFunction) &Dtool_LUIRoot_attach_sprite_43, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIRoot_attach_sprite_43_comment},
  { "attachSprite", (PyCFunction) &Dtool_LUIRoot_attach_sprite_43, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIRoot_attach_sprite_43_comment},
  { "__iadd__", (PyCFunction) &Dtool_LUIRoot_operator_44, METH_O, (char *) Dtool_LUIRoot_operator_44_comment},
  { "load_atlas", (PyCFunction) &Dtool_LUIRoot_load_atlas_45, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIRoot_load_atlas_45_comment},
  { "loadAtlas", (PyCFunction) &Dtool_LUIRoot_load_atlas_45, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUIRoot_load_atlas_45_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions.
//     LUIRoot ...tp_as_number->nb_inplace_add = __iadd__
//////////////////
static PyObject *Dtool_LUIRoot_operator_44__iadd__(PyObject *self, PyObject *arg) {
  return Dtool_LUIRoot_operator_44(self, arg);
}

void Dtool_PyModuleClassInit_LUIRoot(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DTOOL_SUPER_BASE._Dtool_ClassInit(NULL);
    Dtool_LUIRoot.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DTOOL_SUPER_BASE.As_PyTypeObject());
    Dtool_LUIRoot.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUIRoot.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUIRoot.As_PyTypeObject().tp_dict);
#if PY_VERSION_HEX >= 0x2000000
    // tp_as_number->nb_inplace_add = __iadd__
    Dtool_LUIRoot.As_PyTypeObject().tp_as_number->nb_inplace_add = &Dtool_LUIRoot_operator_44__iadd__;
#endif
    if (PyType_Ready(&Dtool_LUIRoot.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUIRoot)");
      printf("Error in PyType_Ready(LUIRoot)");
      return;
    }
    Py_INCREF(&Dtool_LUIRoot.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUIRoot, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUIRoot.As_PyTypeObject());
    PyModule_AddObject(module, "LUIRoot", (PyObject *)&Dtool_LUIRoot.As_PyTypeObject());
  }
}


//********************************************************************
//*** Module Object Linker ..
//********************************************************************
static void BuildInstants(PyObject * module) {
  // Module init upcall for LUIAtlasDescriptor
  Dtool_PyModuleClassInit_LUIAtlasDescriptor(module);
  // Module init upcall for LUIAtlasPacker
  Dtool_PyModuleClassInit_LUIAtlasPacker(module);
  // Module init upcall for LUINode
  Dtool_PyModuleClassInit_LUINode(module);
  // Module init upcall for LUISprite
  Dtool_PyModuleClassInit_LUISprite(module);
  // Module init upcall for LUIRoot
  Dtool_PyModuleClassInit_LUIRoot(module);
//********************************************************************
//*** Module Init Upcall ..  Externally Defined Class
//********************************************************************
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

EXPORT_THIS struct LibraryDef LUI_moddef = {python_simple_funcs, BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1409406023,  /* file_identifier */
  "LUI",  /* library_name */
  "jJ0G",  /* library_hash_name */
  "LUI",  /* module_name */
  "InterrogateModule.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  115  /* next_index */
};

Configure(_in_configure_LUI);
ConfigureFn(_in_configure_LUI) {
  interrogate_request_module(&_in_module_def);
}

