/*
 * This file generated by:
 * F:/P3D/1.9.0-1/built_x64/bin/interrogate -D__inline -DWIN32 -DWIN32_VC -D__int64=long -DCPPPARSER -DP3_INTERROGATE=1 -D__cplusplus -fnames -string -refcount -assert -Dvolatile= -SF:/P3D/1.9.0-1/built_x64/include/parser-inc -SF:/P3D/1.9.0-1/built_x64/include/ -oc Source/InterrogateModule.cxx -od Source/InterrogateModule.in -python-native -module LUI -library LUI -srcdir E:/Projects/Brainz stuff/LUI/Source config_lui.h luiAtlas.h luiNode.h luiRoot.h luiSprite.h luiVertexPool.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_LUI
#include "py_panda.h"
#include "extension.h"

#include "config_lui.h"
#include "dconfig.h"
#include "internalName.h"
#include "luiAtlas.h"
#include "luiNode.h"
#include "luiRoot.h"
#include "luiSprite.h"
#include "luiVertexPool.h"
#include "luse.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pandasymbols.h"
#include "referenceCount.h"
#include "texture.h"

#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif

//********************************************************************
//*** prototypes for .. Global
//********************************************************************
//********************************************************************
//*** prototypes for .. LUINode
//********************************************************************
typedef LUINode LUINode_localtype;
Define_Module_ClassRef(LUI, LUINode, LUINode_localtype, LUINode);

//********************************************************************
//*** prototypes for .. LUISprite
//********************************************************************
typedef LUISprite LUISprite_localtype;
Define_Module_ClassRef(LUI, LUISprite, LUISprite_localtype, LUISprite);

//********************************************************************
//*** prototypes for .. LUIRoot
//********************************************************************
typedef LUIRoot LUIRoot_localtype;
Define_Module_Class(LUI, LUIRoot, LUIRoot_localtype, LUIRoot);

//********************************************************************
//*** prototypes for .. External Objects
//********************************************************************
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LPoint2f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_LVector2f;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct Dtool_PyTypedObject Dtool_Texture;

//********************************************************************
//*** Functions for .. Global
//********************************************************************
//********************************************************************
//*** Functions for .. LUINode
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void LUINode::add_widget(LUINode *node)
 *******************************************************************/
static PyObject *Dtool_LUINode_add_widget_4(PyObject *self, PyObject *arg) {
  LUINode *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUINode, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-void LUINode::add_widget(LUINode *node)
        LUINode *arg_this = (LUINode *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_LUINode, 1, "LUINode.add_widget", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->add_widget(arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUINode.add_widget() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "add_widget(LUINode this, LUINode node)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUINode_add_widget_4_comment =
  "C++ Interface:\n"
  "add_widget(LUINode this, LUINode node)\n"
  "\n"
  "";
#else
static const char *Dtool_LUINode_add_widget_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LUINode::LUINode(void)
 *******************************************************************/
int Dtool_Init_LUINode(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-LUINode::LUINode(void)
  LUINode *return_value = new LUINode();
  return_value->ref();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    delete return_value;
    return -1;
  }
#endif
  return DTool_PyInit_Finalize(self, return_value, &Dtool_LUINode, true, false);

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "LUINode()\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_LUINode(PyObject *self, PyObject *args) {
  return Dtool_Init_LUINode(self, args, NULL);
}

inline void *Dtool_UpcastInterface_LUINode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUINode) {
    printf("LUINode ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUINode *local_this = (LUINode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUINode) {
    return local_this;
  }
  if (requested_type == &Dtool_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUINode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUINode) {
    return from_this;
  }
  if (from_type == &Dtool_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUINode*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. LUISprite
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_pos(LPoint2f const &pos)
 * inline void LUISprite::set_pos(float x, float y)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_pos_8(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUISprite::set_pos(LPoint2f const &pos)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"pos", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_pos", keyword_list, &param1)) {
            LPoint2f *param1_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2f, 1, "LUISprite.set_pos", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_pos(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUISprite.set_pos() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 2: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUISprite::set_pos(float x, float y)
      float param1;
      float param2;
      static char *keyword_list[] = {(char *)"x", (char *)"y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_pos", keyword_list, &param1, &param2)) {
        (local_this)->set_pos((float)param1, (float)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUISprite.set_pos() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_pos() takes 2 or 3 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_pos(LUISprite this, const LPoint2f pos)\n"
      "set_pos(LUISprite this, float x, float y)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_pos_8_comment =
  "C++ Interface:\n"
  "set_pos(LUISprite this, const LPoint2f pos)\n"
  "set_pos(LUISprite this, float x, float y)\n"
  "\n"
  "// Setter / Getter \n"
  "// Position\n"
  "\n"
  "// Setter / Getter \n"
  "// Position\n"
  "";
#else
static const char *Dtool_LUISprite_set_pos_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_x(float x)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_x_9(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_x(float x)
    if (PyNumber_Check(arg)) {
      (local_this)->set_x((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_x() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_x(LUISprite this, float x)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_x_9_comment =
  "C++ Interface:\n"
  "set_x(LUISprite this, float x)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_x_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_y(float y)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_y_10(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_y(float y)
    if (PyNumber_Check(arg)) {
      (local_this)->set_y((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_y() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_y(LUISprite this, float y)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_y_10_comment =
  "C++ Interface:\n"
  "set_y(LUISprite this, float y)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_y_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LUISprite::get_x(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_x_11(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float LUISprite::get_x(void)
    float return_value = (local_this)->get_x();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyFloat_FromDouble(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_x() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_x(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_x_11_comment =
  "C++ Interface:\n"
  "get_x(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_x_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LUISprite::get_y(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_y_12(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float LUISprite::get_y(void)
    float return_value = (local_this)->get_y();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyFloat_FromDouble(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_y() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_y(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_y_12_comment =
  "C++ Interface:\n"
  "get_y(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_y_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint2f LUISprite::get_pos(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_pos_13(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LPoint2f LUISprite::get_pos(void)
    LPoint2f result = (local_this)->get_pos();
    LPoint2f *return_value = new LPoint2f(result);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_LPoint2f, true, false);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_pos() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_pos(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_pos_13_comment =
  "C++ Interface:\n"
  "get_pos(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_pos_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_size(LVector2f const &size)
 * inline void LUISprite::set_size(float w, float h)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_size_14(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUISprite::set_size(LVector2f const &size)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"size", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_size", keyword_list, &param1)) {
            LVector2f *param1_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector2f, 1, "LUISprite.set_size", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_size(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUISprite.set_size() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 2: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUISprite::set_size(float w, float h)
      float param1;
      float param2;
      static char *keyword_list[] = {(char *)"w", (char *)"h", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_size", keyword_list, &param1, &param2)) {
        (local_this)->set_size((float)param1, (float)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUISprite.set_size() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_size() takes 2 or 3 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_size(LUISprite this, const LVector2f size)\n"
      "set_size(LUISprite this, float w, float h)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_size_14_comment =
  "C++ Interface:\n"
  "set_size(LUISprite this, const LVector2f size)\n"
  "set_size(LUISprite this, float w, float h)\n"
  "\n"
  "// Size\n"
  "\n"
  "// Size\n"
  "";
#else
static const char *Dtool_LUISprite_set_size_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_width(float w)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_width_15(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_width(float w)
    if (PyNumber_Check(arg)) {
      (local_this)->set_width((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_width() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_width(LUISprite this, float w)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_width_15_comment =
  "C++ Interface:\n"
  "set_width(LUISprite this, float w)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_width_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_height(float h)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_height_16(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_height(float h)
    if (PyNumber_Check(arg)) {
      (local_this)->set_height((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_height() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_height(LUISprite this, float h)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_height_16_comment =
  "C++ Interface:\n"
  "set_height(LUISprite this, float h)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_height_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LUISprite::get_width(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_width_17(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float LUISprite::get_width(void)
    float return_value = (local_this)->get_width();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyFloat_FromDouble(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_width() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_width(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_width_17_comment =
  "C++ Interface:\n"
  "get_width(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_width_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LUISprite::get_height(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_height_18(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float LUISprite::get_height(void)
    float return_value = (local_this)->get_height();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyFloat_FromDouble(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_height() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_height(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_height_18_comment =
  "C++ Interface:\n"
  "get_height(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_height_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f const &LUISprite::get_size(void) const
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_size_19(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  // 1-inline LVector2f const &LUISprite::get_size(void) const
  LVector2f const *return_value = &(((const LUISprite*)local_this)->get_size());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    return (PyObject *)NULL;
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, false, true);
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_size(const LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_size_19_comment =
  "C++ Interface:\n"
  "get_size(const LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_size_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_texcoord_start(LVector2f const &texcoord_start)
 * inline void LUISprite::set_texcoord_start(float u, float v)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_texcoord_start_20(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUISprite::set_texcoord_start(LVector2f const &texcoord_start)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"texcoord_start", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_texcoord_start", keyword_list, &param1)) {
            LVector2f *param1_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector2f, 1, "LUISprite.set_texcoord_start", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_texcoord_start(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUISprite.set_texcoord_start() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 2: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUISprite::set_texcoord_start(float u, float v)
      float param1;
      float param2;
      static char *keyword_list[] = {(char *)"u", (char *)"v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_texcoord_start", keyword_list, &param1, &param2)) {
        (local_this)->set_texcoord_start((float)param1, (float)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUISprite.set_texcoord_start() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_texcoord_start() takes 2 or 3 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_texcoord_start(LUISprite this, const LVector2f texcoord_start)\n"
      "set_texcoord_start(LUISprite this, float u, float v)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_texcoord_start_20_comment =
  "C++ Interface:\n"
  "set_texcoord_start(LUISprite this, const LVector2f texcoord_start)\n"
  "set_texcoord_start(LUISprite this, float u, float v)\n"
  "\n"
  "// Texcoord\n"
  "\n"
  "// Texcoord\n"
  "";
#else
static const char *Dtool_LUISprite_set_texcoord_start_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f LUISprite::get_texcoord_start(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_texcoord_start_21(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVector2f LUISprite::get_texcoord_start(void)
    LVector2f result = (local_this)->get_texcoord_start();
    LVector2f *return_value = new LVector2f(result);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, true, false);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_texcoord_start() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_texcoord_start(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_texcoord_start_21_comment =
  "C++ Interface:\n"
  "get_texcoord_start(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_texcoord_start_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_texcoord_end(LVector2f const &texcoord_end)
 * inline void LUISprite::set_texcoord_end(float u, float v)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_texcoord_end_22(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUISprite::set_texcoord_end(LVector2f const &texcoord_end)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"texcoord_end", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_texcoord_end", keyword_list, &param1)) {
            LVector2f *param1_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector2f, 1, "LUISprite.set_texcoord_end", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_texcoord_end(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUISprite.set_texcoord_end() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 2: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUISprite::set_texcoord_end(float u, float v)
      float param1;
      float param2;
      static char *keyword_list[] = {(char *)"u", (char *)"v", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_texcoord_end", keyword_list, &param1, &param2)) {
        (local_this)->set_texcoord_end((float)param1, (float)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUISprite.set_texcoord_end() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_texcoord_end() takes 2 or 3 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_texcoord_end(LUISprite this, const LVector2f texcoord_end)\n"
      "set_texcoord_end(LUISprite this, float u, float v)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_texcoord_end_22_comment =
  "C++ Interface:\n"
  "set_texcoord_end(LUISprite this, const LVector2f texcoord_end)\n"
  "set_texcoord_end(LUISprite this, float u, float v)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_set_texcoord_end_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f LUISprite::get_texcoord_end(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_texcoord_end_23(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVector2f LUISprite::get_texcoord_end(void)
    LVector2f result = (local_this)->get_texcoord_end();
    LVector2f *return_value = new LVector2f(result);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_LVector2f, true, false);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_texcoord_end() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_texcoord_end(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_texcoord_end_23_comment =
  "C++ Interface:\n"
  "get_texcoord_end(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_texcoord_end_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_color(LVecBase4f const &color)
 * inline void LUISprite::set_color(float r, float g, float b, float a)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_color_24(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  int parameter_count = PyTuple_Size(args);
  if (kwds != NULL && PyDict_Check(kwds)) {
    parameter_count += PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1: {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LUISprite::set_color(LVecBase4f const &color)
          PyObject *param1;
          static char *keyword_list[] = {(char *)"color", NULL};
          if (PyArg_ParseTupleAndKeywords(args, kwds, "O:set_color", keyword_list, &param1)) {
            LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "LUISprite.set_color", 1, coerced_ptr, report_errors);

            if (param1_this != NULL) {
              (local_this)->set_color(*param1_this);
              Py_XDECREF(coerced);
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              Py_INCREF(Py_None);
              return Py_None;
            }
          }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LUISprite.set_color() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    break;
  }
  case 4: {

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LUISprite::set_color(float r, float g, float b, float a)
      float param1;
      float param2;
      float param3;
      float param4;
      static char *keyword_list[] = {(char *)"r", (char *)"g", (char *)"b", (char *)"a", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_color", keyword_list, &param1, &param2, &param3, &param4)) {
        (local_this)->set_color((float)param1, (float)param2, (float)param3, (float)param4);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
          notify->clear_assert_failed();
          return (PyObject *)NULL;
        }
#endif
        Py_INCREF(Py_None);
        return Py_None;
      }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LUISprite.set_color() on a const object.");
      return (PyObject *) NULL;
    }

    break;
  }
  default:
    PyErr_Format(PyExc_TypeError, "set_color() takes 2 or 5 arguments (%d given)", parameter_count + 1);
    return (PyObject *) NULL;
  }
  if (!PyErr_Occurred()) { // Let error pass on
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match one of:\n"
      "set_color(LUISprite this, const LVecBase4f color)\n"
      "set_color(LUISprite this, float r, float g, float b, float a)\n"
      "");
 }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_color_24_comment =
  "C++ Interface:\n"
  "set_color(LUISprite this, const LVecBase4f color)\n"
  "set_color(LUISprite this, float r, float g, float b, float a)\n"
  "\n"
  "// Color\n"
  "\n"
  "// Color\n"
  "";
#else
static const char *Dtool_LUISprite_set_color_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f LUISprite::get_color(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_color_25(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LVecBase4f LUISprite::get_color(void)
    LVecBase4f result = (local_this)->get_color();
    LVecBase4f *return_value = new LVecBase4f(result);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstance((void *)return_value, Dtool_LVecBase4f, true, false);
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_color() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_color(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_color_25_comment =
  "C++ Interface:\n"
  "get_color(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_get_color_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_texture(Texture *tex)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_texture_26(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }
  {
    PyObject *coerced = NULL;
    PyObject **coerced_ptr = NULL;
    bool report_errors = false;
    while (true) {
      if (!((Dtool_PyInstDef *)self)->_is_const) {
        // 1-inline void LUISprite::set_texture(Texture *tex)
        Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, &Dtool_Texture, 1, "LUISprite.set_texture", 0, coerced_ptr, report_errors);

        if (arg_this != NULL) {
          (local_this)->set_texture(arg_this);
          Py_XDECREF(coerced);
#ifndef NDEBUG
          Notify *notify = Notify::ptr();
          if (notify->has_assert_failed()) {
            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
            notify->clear_assert_failed();
            return (PyObject *)NULL;
          }
#endif
          Py_INCREF(Py_None);
          return Py_None;
        }
      } else {
        PyErr_SetString(PyExc_TypeError,
                        "Cannot call LUISprite.set_texture() on a const object.");
        return (PyObject *) NULL;
      }

      if (coerced_ptr == NULL && !report_errors) {
        coerced_ptr = &coerced;
        continue;
      }
      if (!report_errors) {
        report_errors = true;
        continue;
      }
      break;
    }
    Py_XDECREF(coerced);
  }
  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_texture(LUISprite this, Texture tex)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_texture_26_comment =
  "C++ Interface:\n"
  "set_texture(LUISprite this, Texture tex)\n"
  "\n"
  "// Texture\n"
  "";
#else
static const char *Dtool_LUISprite_set_texture_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Texture *LUISprite::get_texture(void) const
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_texture_27(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  // 1-inline Texture *LUISprite::get_texture(void) const
  Texture *return_value = ((const LUISprite*)local_this)->get_texture();
  if (return_value != (Texture *)0) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    return (PyObject *)NULL;
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, Dtool_Texture, true, false, (return_value)->as_typed_object()->get_type_index());
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_texture(const LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_texture_27_comment =
  "C++ Interface:\n"
  "get_texture(const LUISprite this)\n"
  "\n"
  "// Texture\n"
  "";
#else
static const char *Dtool_LUISprite_get_texture_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_z_index(float z_index)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_z_index_28(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_z_index(float z_index)
    if (PyNumber_Check(arg)) {
      (local_this)->set_z_index((float) PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
        notify->clear_assert_failed();
        return (PyObject *)NULL;
      }
#endif
      Py_INCREF(Py_None);
      return Py_None;
    }
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_z_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_z_index(LUISprite this, float z_index)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_z_index_28_comment =
  "C++ Interface:\n"
  "set_z_index(LUISprite this, float z_index)\n"
  "\n"
  "// Z-Index\n"
  "";
#else
static const char *Dtool_LUISprite_set_z_index_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LUISprite::get_z_index(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_get_z_index_29(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline float LUISprite::get_z_index(void)
    float return_value = (local_this)->get_z_index();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyFloat_FromDouble(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.get_z_index() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "get_z_index(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_z_index_29_comment =
  "C++ Interface:\n"
  "get_z_index(LUISprite this)\n"
  "\n"
  "// Z-Index\n"
  "";
#else
static const char *Dtool_LUISprite_get_z_index_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::set_visible(bool visible)
 *******************************************************************/
static PyObject *Dtool_LUISprite_set_visible_30(PyObject *self, PyObject *arg) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::set_visible(bool visible)
    (local_this)->set_visible((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.set_visible() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "set_visible(LUISprite this, bool visible)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_visible_30_comment =
  "C++ Interface:\n"
  "set_visible(LUISprite this, bool visible)\n"
  "\n"
  "// Visible\n"
  "";
#else
static const char *Dtool_LUISprite_set_visible_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool LUISprite::is_visible(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_is_visible_31(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline bool LUISprite::is_visible(void)
    bool return_value = (local_this)->is_visible();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    return PyBool_FromLong(return_value);
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.is_visible() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "is_visible(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_is_visible_31_comment =
  "C++ Interface:\n"
  "is_visible(LUISprite this)\n"
  "\n"
  "// Visible\n"
  "";
#else
static const char *Dtool_LUISprite_is_visible_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::hide(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_hide_32(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::hide(void)
    (local_this)->hide();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.hide() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "hide(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_hide_32_comment =
  "C++ Interface:\n"
  "hide(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_hide_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LUISprite::show(void)
 *******************************************************************/
static PyObject *Dtool_LUISprite_show_33(PyObject *self) {
  LUISprite *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LUISprite, (void **)&local_this);
  if (local_this == NULL) {
    PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
    return NULL;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LUISprite::show(void)
    (local_this)->show();
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
      notify->clear_assert_failed();
      return (PyObject *)NULL;
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    PyErr_SetString(PyExc_TypeError,
                    "Cannot call LUISprite.show() on a const object.");
    return (PyObject *) NULL;
  }

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "show(LUISprite this)\n"
      "");
  }
  return (PyObject *) NULL;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_show_33_comment =
  "C++ Interface:\n"
  "show(LUISprite this)\n"
  "\n"
  "";
#else
static const char *Dtool_LUISprite_show_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LUISprite::LUISprite(void)
 *******************************************************************/
int Dtool_Init_LUISprite(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-LUISprite::LUISprite(void)
  LUISprite *return_value = new LUISprite();
  return_value->ref();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    delete return_value;
    return -1;
  }
#endif
  return DTool_PyInit_Finalize(self, return_value, &Dtool_LUISprite, true, false);

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "LUISprite()\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_LUISprite(PyObject *self, PyObject *args) {
  return Dtool_Init_LUISprite(self, args, NULL);
}

inline void *Dtool_UpcastInterface_LUISprite(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUISprite) {
    printf("LUISprite ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUISprite *local_this = (LUISprite *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUISprite) {
    return local_this;
  }
  if (requested_type == &Dtool_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUISprite(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUISprite) {
    return from_this;
  }
  if (from_type == &Dtool_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUISprite*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. LUIRoot
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LUIRoot::LUIRoot(void)
 *******************************************************************/
int Dtool_Init_LUIRoot(PyObject *self, PyObject *args, PyObject *kwds) {

  // 1-LUIRoot::LUIRoot(void)
  LUIRoot *return_value = new LUIRoot();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
    notify->clear_assert_failed();
    delete return_value;
    return -1;
  }
#endif
  return DTool_PyInit_Finalize(self, return_value, &Dtool_LUIRoot, true, false);

  if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
      "Arguments must match:\n"
      "LUIRoot()\n"
      "");
  }
  return -1;
}


int Dtool_InitNoCoerce_LUIRoot(PyObject *self, PyObject *args) {
  return Dtool_Init_LUIRoot(self, args, NULL);
}

inline void *Dtool_UpcastInterface_LUIRoot(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != &Dtool_LUIRoot) {
    printf("LUIRoot ** Bad Source Type-- Requesting Conversion from %s to %s\n", ((Dtool_PyInstDef *)self)->_My_Type->_name, requested_type->_name); fflush(NULL);
    return NULL;
  }

  LUIRoot *local_this = (LUIRoot *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == &Dtool_LUIRoot) {
    return local_this;
  }
  return NULL;
}

inline void *Dtool_DowncastInterface_LUIRoot(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == &Dtool_LUIRoot) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Py Init Code For .. LUINode | LUINode
//********************************************************************
PyMethodDef Dtool_Methods_LUINode[] = {
  { "add_widget", (PyCFunction) &Dtool_LUINode_add_widget_4, METH_O, (char *) Dtool_LUINode_add_widget_4_comment},
  { "addWidget", (PyCFunction) &Dtool_LUINode_add_widget_4, METH_O, (char *) Dtool_LUINode_add_widget_4_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_LUINode(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ReferenceCount._Dtool_ClassInit(NULL);
    Dtool_LUINode.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_ReferenceCount.As_PyTypeObject());
    Dtool_LUINode.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUINode.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUINode.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_LUINode.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUINode)");
      printf("Error in PyType_Ready(LUINode)");
      return;
    }
    Py_INCREF(&Dtool_LUINode.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUINode, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUINode.As_PyTypeObject());
    PyModule_AddObject(module, "LUINode", (PyObject *)&Dtool_LUINode.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. LUISprite | LUISprite
//********************************************************************
PyMethodDef Dtool_Methods_LUISprite[] = {
  { "set_pos", (PyCFunction) &Dtool_LUISprite_set_pos_8, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_pos_8_comment},
  { "setPos", (PyCFunction) &Dtool_LUISprite_set_pos_8, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_pos_8_comment},
  { "set_x", (PyCFunction) &Dtool_LUISprite_set_x_9, METH_O, (char *) Dtool_LUISprite_set_x_9_comment},
  { "setX", (PyCFunction) &Dtool_LUISprite_set_x_9, METH_O, (char *) Dtool_LUISprite_set_x_9_comment},
  { "set_y", (PyCFunction) &Dtool_LUISprite_set_y_10, METH_O, (char *) Dtool_LUISprite_set_y_10_comment},
  { "setY", (PyCFunction) &Dtool_LUISprite_set_y_10, METH_O, (char *) Dtool_LUISprite_set_y_10_comment},
  { "get_x", (PyCFunction) &Dtool_LUISprite_get_x_11, METH_NOARGS, (char *) Dtool_LUISprite_get_x_11_comment},
  { "getX", (PyCFunction) &Dtool_LUISprite_get_x_11, METH_NOARGS, (char *) Dtool_LUISprite_get_x_11_comment},
  { "get_y", (PyCFunction) &Dtool_LUISprite_get_y_12, METH_NOARGS, (char *) Dtool_LUISprite_get_y_12_comment},
  { "getY", (PyCFunction) &Dtool_LUISprite_get_y_12, METH_NOARGS, (char *) Dtool_LUISprite_get_y_12_comment},
  { "get_pos", (PyCFunction) &Dtool_LUISprite_get_pos_13, METH_NOARGS, (char *) Dtool_LUISprite_get_pos_13_comment},
  { "getPos", (PyCFunction) &Dtool_LUISprite_get_pos_13, METH_NOARGS, (char *) Dtool_LUISprite_get_pos_13_comment},
  { "set_size", (PyCFunction) &Dtool_LUISprite_set_size_14, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_size_14_comment},
  { "setSize", (PyCFunction) &Dtool_LUISprite_set_size_14, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_size_14_comment},
  { "set_width", (PyCFunction) &Dtool_LUISprite_set_width_15, METH_O, (char *) Dtool_LUISprite_set_width_15_comment},
  { "setWidth", (PyCFunction) &Dtool_LUISprite_set_width_15, METH_O, (char *) Dtool_LUISprite_set_width_15_comment},
  { "set_height", (PyCFunction) &Dtool_LUISprite_set_height_16, METH_O, (char *) Dtool_LUISprite_set_height_16_comment},
  { "setHeight", (PyCFunction) &Dtool_LUISprite_set_height_16, METH_O, (char *) Dtool_LUISprite_set_height_16_comment},
  { "get_width", (PyCFunction) &Dtool_LUISprite_get_width_17, METH_NOARGS, (char *) Dtool_LUISprite_get_width_17_comment},
  { "getWidth", (PyCFunction) &Dtool_LUISprite_get_width_17, METH_NOARGS, (char *) Dtool_LUISprite_get_width_17_comment},
  { "get_height", (PyCFunction) &Dtool_LUISprite_get_height_18, METH_NOARGS, (char *) Dtool_LUISprite_get_height_18_comment},
  { "getHeight", (PyCFunction) &Dtool_LUISprite_get_height_18, METH_NOARGS, (char *) Dtool_LUISprite_get_height_18_comment},
  { "get_size", (PyCFunction) &Dtool_LUISprite_get_size_19, METH_NOARGS, (char *) Dtool_LUISprite_get_size_19_comment},
  { "getSize", (PyCFunction) &Dtool_LUISprite_get_size_19, METH_NOARGS, (char *) Dtool_LUISprite_get_size_19_comment},
  { "set_texcoord_start", (PyCFunction) &Dtool_LUISprite_set_texcoord_start_20, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_texcoord_start_20_comment},
  { "setTexcoordStart", (PyCFunction) &Dtool_LUISprite_set_texcoord_start_20, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_texcoord_start_20_comment},
  { "get_texcoord_start", (PyCFunction) &Dtool_LUISprite_get_texcoord_start_21, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_start_21_comment},
  { "getTexcoordStart", (PyCFunction) &Dtool_LUISprite_get_texcoord_start_21, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_start_21_comment},
  { "set_texcoord_end", (PyCFunction) &Dtool_LUISprite_set_texcoord_end_22, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_texcoord_end_22_comment},
  { "setTexcoordEnd", (PyCFunction) &Dtool_LUISprite_set_texcoord_end_22, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_texcoord_end_22_comment},
  { "get_texcoord_end", (PyCFunction) &Dtool_LUISprite_get_texcoord_end_23, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_end_23_comment},
  { "getTexcoordEnd", (PyCFunction) &Dtool_LUISprite_get_texcoord_end_23, METH_NOARGS, (char *) Dtool_LUISprite_get_texcoord_end_23_comment},
  { "set_color", (PyCFunction) &Dtool_LUISprite_set_color_24, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_color_24_comment},
  { "setColor", (PyCFunction) &Dtool_LUISprite_set_color_24, METH_VARARGS | METH_KEYWORDS, (char *) Dtool_LUISprite_set_color_24_comment},
  { "get_color", (PyCFunction) &Dtool_LUISprite_get_color_25, METH_NOARGS, (char *) Dtool_LUISprite_get_color_25_comment},
  { "getColor", (PyCFunction) &Dtool_LUISprite_get_color_25, METH_NOARGS, (char *) Dtool_LUISprite_get_color_25_comment},
  { "set_texture", (PyCFunction) &Dtool_LUISprite_set_texture_26, METH_O, (char *) Dtool_LUISprite_set_texture_26_comment},
  { "setTexture", (PyCFunction) &Dtool_LUISprite_set_texture_26, METH_O, (char *) Dtool_LUISprite_set_texture_26_comment},
  { "get_texture", (PyCFunction) &Dtool_LUISprite_get_texture_27, METH_NOARGS, (char *) Dtool_LUISprite_get_texture_27_comment},
  { "getTexture", (PyCFunction) &Dtool_LUISprite_get_texture_27, METH_NOARGS, (char *) Dtool_LUISprite_get_texture_27_comment},
  { "set_z_index", (PyCFunction) &Dtool_LUISprite_set_z_index_28, METH_O, (char *) Dtool_LUISprite_set_z_index_28_comment},
  { "setZIndex", (PyCFunction) &Dtool_LUISprite_set_z_index_28, METH_O, (char *) Dtool_LUISprite_set_z_index_28_comment},
  { "get_z_index", (PyCFunction) &Dtool_LUISprite_get_z_index_29, METH_NOARGS, (char *) Dtool_LUISprite_get_z_index_29_comment},
  { "getZIndex", (PyCFunction) &Dtool_LUISprite_get_z_index_29, METH_NOARGS, (char *) Dtool_LUISprite_get_z_index_29_comment},
  { "set_visible", (PyCFunction) &Dtool_LUISprite_set_visible_30, METH_O, (char *) Dtool_LUISprite_set_visible_30_comment},
  { "setVisible", (PyCFunction) &Dtool_LUISprite_set_visible_30, METH_O, (char *) Dtool_LUISprite_set_visible_30_comment},
  { "is_visible", (PyCFunction) &Dtool_LUISprite_is_visible_31, METH_NOARGS, (char *) Dtool_LUISprite_is_visible_31_comment},
  { "isVisible", (PyCFunction) &Dtool_LUISprite_is_visible_31, METH_NOARGS, (char *) Dtool_LUISprite_is_visible_31_comment},
  { "hide", (PyCFunction) &Dtool_LUISprite_hide_32, METH_NOARGS, (char *) Dtool_LUISprite_hide_32_comment},
  { "show", (PyCFunction) &Dtool_LUISprite_show_33, METH_NOARGS, (char *) Dtool_LUISprite_show_33_comment},
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_LUISprite(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
#ifndef NDEBUG
    // Class documentation string
    Dtool_LUISprite.As_PyTypeObject().tp_doc =
      "////////////////////////////////////////////////////////////////////\n"
      "//       Class : LUISprite\n"
      "// Description : A LUISprite stores a single card, including position,\n"
      "//               scale, and uv coordinates. It also notifies the\n"
      "//               LUIVertexPool when any scalar or texture got changed.\n"
      "////////////////////////////////////////////////////////////////////";
#endif
    // Dependent objects
    Dtool_ReferenceCount._Dtool_ClassInit(NULL);
    Dtool_LUISprite.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_ReferenceCount.As_PyTypeObject());
    Dtool_LUISprite.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUISprite.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUISprite.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_LUISprite.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUISprite)");
      printf("Error in PyType_Ready(LUISprite)");
      return;
    }
    Py_INCREF(&Dtool_LUISprite.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUISprite, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUISprite.As_PyTypeObject());
    PyModule_AddObject(module, "LUISprite", (PyObject *)&Dtool_LUISprite.As_PyTypeObject());
  }
}

//********************************************************************
//*** Py Init Code For .. LUIRoot | LUIRoot
//********************************************************************
PyMethodDef Dtool_Methods_LUIRoot[] = {
  { NULL, NULL }
};

void Dtool_PyModuleClassInit_LUIRoot(PyObject *module) {
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DTOOL_SUPER_BASE._Dtool_ClassInit(NULL);
    Dtool_LUIRoot.As_PyTypeObject().tp_bases = PyTuple_Pack(1, &Dtool_DTOOL_SUPER_BASE.As_PyTypeObject());
    Dtool_LUIRoot.As_PyTypeObject().tp_dict = PyDict_New();
    PyDict_SetItemString(Dtool_LUIRoot.As_PyTypeObject().tp_dict, "DtoolClassDict", Dtool_LUIRoot.As_PyTypeObject().tp_dict);
    if (PyType_Ready(&Dtool_LUIRoot.As_PyTypeObject()) < 0) {
      PyErr_SetString(PyExc_TypeError, "PyType_Ready(LUIRoot)");
      printf("Error in PyType_Ready(LUIRoot)");
      return;
    }
    Py_INCREF(&Dtool_LUIRoot.As_PyTypeObject());
    RegisterRuntimeClass(&Dtool_LUIRoot, -1);
  }
  if (module != NULL) {
    Py_INCREF(&Dtool_LUIRoot.As_PyTypeObject());
    PyModule_AddObject(module, "LUIRoot", (PyObject *)&Dtool_LUIRoot.As_PyTypeObject());
  }
}


//********************************************************************
//*** Module Object Linker ..
//********************************************************************
static void BuildInstants(PyObject * module) {
  // Module init upcall for LUINode
  Dtool_PyModuleClassInit_LUINode(module);
  // Module init upcall for LUISprite
  Dtool_PyModuleClassInit_LUISprite(module);
  // Module init upcall for LUIRoot
  Dtool_PyModuleClassInit_LUIRoot(module);
//********************************************************************
//*** Module Init Upcall ..  Externally Defined Class
//********************************************************************
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

EXPORT_THIS struct LibraryDef LUI_moddef = {python_simple_funcs, BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1409327601,  /* file_identifier */
  "LUI",  /* library_name */
  "jJ0G",  /* library_hash_name */
  "LUI",  /* module_name */
  "InterrogateModule.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  98  /* next_index */
};

Configure(_in_configure_LUI);
ConfigureFn(_in_configure_LUI) {
  interrogate_request_module(&_in_module_def);
}

